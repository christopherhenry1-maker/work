/**
 * ============================================================================
 * EXECUTIVE DASHBOARD - COMPLETE GOOGLE APPS SCRIPT
 * ============================================================================
 * VP of Value Brands - Executive Command Center
 * 
 * FEATURES:
 * - Auto-creates sheet tabs if they don't exist
 * - Syncs executive's Google Calendar to Meetings sheet
 * - Serves dashboard with real-time data
 * - Creates agenda documents
 * - Supports recurring meeting management
 * 
 * Version: 2.0 (Complete with Calendar Sync)
 * Last Updated: January 27, 2026
 * ============================================================================
 */

// ============================================================================
// CONFIGURATION - UPDATE THESE
// ============================================================================

const CONFIG = {
  // Main Sheet IDs
  DELIVERABLES_SHEET_ID: '1ZmC-04S_OdhuoJs-XIBiOujj5rtsJTZNOiH26_0LTgk',
  
  // If meetings are in same workbook, use same ID:
  MEETINGS_SHEET_ID: '1ZmC-04S_OdhuoJs-XIBiOujj5rtsJTZNOiH26_0LTgk',
  
  // Tab/Sheet Names (will be auto-created if missing)
  MEETINGS_TAB_NAME: 'Meetings',
  DELIVERABLES_TAB_NAME: 'Document Repository',
  ARCHIVE_TAB_NAME: 'Meeting Archive', // NEW - for completed meetings
  
  // Calendar Settings for Auto-Sync
  EXECUTIVE_CALENDAR_ID: 'michael.sarcone@verizon.com',
  SYNC_DAYS_AHEAD: 90,      // Pull meetings 90 days forward
  SYNC_DAYS_BEHIND: 30,     // Pull meetings 30 days back
  
  // Row ranges for Document Repository sheet
  // 
  // ‚≠ê IMPORTANT: These ranges are FLEXIBLE!
  // The code uses DYNAMIC detection and stops at the first empty row.
  // You can add/remove rows freely - just update START_ROW if sections move.
  // END_ROW values are safety limits, not hard requirements.
  // 
  // ‚úÖ You CAN change section names in the sheet without breaking code
  // ‚úÖ You CAN add more rows without updating END_ROW
  // ‚úÖ You CAN move sections - just update START_ROW values below
  
  EXEC1_START_ROW: 3,          // Exec 1 Deliverables (Skipping Title)
  EXEC1_END_ROW: 20,
  
  EXEC2_START_ROW: 23,         // Exec 2 Deliverables (Skipping Title)
  EXEC2_END_ROW: 35,
  
  ADMIN_START_ROW: 38,         // Admin & Settings Links (Skipping Title)
  ADMIN_END_ROW: 45,
  
  KPI_START_ROW: 49,           // KPIs & Performance (Skipping Title)
  KPI_END_ROW: 60,
  
  EXEC_UPDATES_START_ROW: 63,  // Executive Updates Archive (Skipping Title)
  EXEC_UPDATES_END_ROW: 110,
  
  DOCUMENTS_START_ROW: 163,    // Document Repository Section (Skipping Title)
  DOCUMENTS_END_ROW: 212,
  
  COMPLETED_START_ROW: 215,    // Completed Items (Skipping Title)
  COMPLETED_END_ROW: 314,
  
  // Alert Banner Settings
  ALERT_SHEET_NAME: 'Alerts',
  ALERT_START_ROW: 2,
  
  // Column indices for Meetings sheet (0-indexed)
  MEETING_COLUMNS: {
    COMPLETE: 0,         // A
    APPROVED: 1,         // B
    HOT_TOPIC: 2,        // C
    MEETING_NAME: 3,     // D
    DATE: 4,             // E
    TIME: 5,             // F
    DURATION: 6,         // G
    FREQUENCY: 7,        // H
    CATEGORY: 8,         // I
    DESCRIPTION: 9,      // J
    ATTENDEES: 10,       // K
    DELIVERABLE_LINK: 11,// L
    PREP_REQUIRED: 12,   // M
    NOTES: 14,           // O (N is empty column)
    EVENT_ID: 15         // P
  }
};

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Setup function - Initializes sheets (run this first!)
 */
function setup() {
  ensureSheetsExist();
  Logger.log('‚úÖ Setup complete!');
  Logger.log('üìä Sheets verified/created');
  Logger.log('');
  Logger.log('üöÄ Next steps:');
  Logger.log('1. Refresh your Google Sheet to see the menu');
  Logger.log('2. Use menu: üìä Executive Dashboard > üîÑ Sync Calendar Now');
  Logger.log('3. Deploy as Web App (Deploy > New Deployment)');
}

/**
 * Create custom menu - called automatically when sheet opens
 */
function onOpen() {
  createCustomMenu();
}

/**
 * Create custom menu in Google Sheets
 */
function createCustomMenu() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üìä Executive Dashboard')
    .addItem('üîÑ Sync Calendar Now', 'syncCalendarToMeetingsSheet')
    .addItem('üìÖ Setup Daily Auto-Sync', 'setupDailySyncTrigger')
    .addItem('üóëÔ∏è Remove Auto-Sync', 'removeSyncTriggers')
    .addSeparator()
    .addItem('üì¶ Archive Completed Meetings', 'archiveCompletedMeetings')
    .addSeparator()
    .addItem('üèóÔ∏è Initialize Sheets', 'ensureSheetsExist')
    .addItem('üß™ Test Data Retrieval', 'testDataRetrieval')
    .addToUi();
}

/**
 * Ensure all required sheets exist, create if missing
 */
function ensureSheetsExist() {
  const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
  
  let sheetsCreated = [];
  
  // Create Meetings sheet if missing
  let meetingsSheet = ss.getSheetByName(CONFIG.MEETINGS_TAB_NAME);
  if (!meetingsSheet) {
    Logger.log('üìù Creating Meetings sheet...');
    meetingsSheet = ss.insertSheet(CONFIG.MEETINGS_TAB_NAME);
    initializeMeetingsSheet(meetingsSheet);
    sheetsCreated.push(CONFIG.MEETINGS_TAB_NAME);
  } else {
    Logger.log('‚úÖ Meetings sheet already exists');
  }
  
  // Create Deliverables sheet if missing
  let deliverablesSheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
  if (!deliverablesSheet) {
    Logger.log('üìù Creating Team Updates sheet...');
    deliverablesSheet = ss.insertSheet(CONFIG.DELIVERABLES_TAB_NAME);
    initializeDeliverablesSheet(deliverablesSheet);
    sheetsCreated.push(CONFIG.DELIVERABLES_TAB_NAME);
  } else {
    Logger.log('‚úÖ Team Updates sheet already exists');
  }
  
  // Show results
  if (sheetsCreated.length > 0) {
    Logger.log('‚úÖ Created sheets: ' + sheetsCreated.join(', '));
    // Try to show UI alert if possible, but don't fail if not
    try {
      SpreadsheetApp.getUi().alert('‚úÖ Sheets Created!\n\nNew sheets:\n‚Ä¢ ' + sheetsCreated.join('\n‚Ä¢ '));
    } catch (e) {
      Logger.log('(Running from script editor - UI alerts disabled)');
    }
  } else {
    Logger.log('‚úÖ All required sheets already exist');
    try {
      SpreadsheetApp.getUi().alert('‚úÖ All sheets verified!\n\nExisting sheets:\n‚Ä¢ ' + CONFIG.MEETINGS_TAB_NAME + '\n‚Ä¢ ' + CONFIG.DELIVERABLES_TAB_NAME);
    } catch (e) {
      Logger.log('(Running from script editor - UI alerts disabled)');
    }
  }
}

/**
 * Initialize Meetings sheet with headers
 */
function initializeMeetingsSheet(sheet) {
  const headers = [
    'COMPLETE', 'APPROVED', 'HOT TOPIC', 'MEETING NAME', 'DATE', 'TIME',
    'DURATION', 'FREQUENCY', 'CATEGORY', 'DESCRIPTION', 'ATTENDEES',
    'DELIVERABLE LINK', 'PREP REQUIRED', '', 'NOTES', 'EVENT ID'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length)
    .setFontWeight('bold')
    .setBackground('#1e293b')
    .setFontColor('#ffffff')
    .setHorizontalAlignment('center');
  
  // Set column widths
  sheet.setColumnWidth(1, 80);  // Complete
  sheet.setColumnWidth(2, 80);  // Approved
  sheet.setColumnWidth(3, 90);  // Hot Topic
  sheet.setColumnWidth(4, 250); // Meeting Name
  sheet.setColumnWidth(5, 100); // Date
  sheet.setColumnWidth(6, 80);  // Time
  sheet.setColumnWidth(7, 90);  // Duration
  sheet.setColumnWidth(8, 100); // Frequency
  sheet.setColumnWidth(9, 120); // Category
  sheet.setColumnWidth(10, 300);// Description
  sheet.setColumnWidth(11, 200);// Attendees
  sheet.setColumnWidth(12, 200);// Deliverable Link
  sheet.setColumnWidth(13, 110);// Prep Required
  sheet.setColumnWidth(14, 50); // Empty
  sheet.setColumnWidth(15, 250);// Notes
  sheet.setColumnWidth(16, 200);// Event ID
  
  // Format checkboxes
  sheet.getRange('A2:C1000').insertCheckboxes();
  sheet.getRange('M2:M1000').insertCheckboxes();
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  Logger.log('‚úÖ Meetings sheet initialized with headers and formatting');
}

/**
 * Initialize Deliverables sheet with section headers
 */
function initializeDeliverablesSheet(sheet) {
  const sections = [
    { row: 1, title: 'Exec 1 Upcoming Deliverables & Hot Topics' },
    { row: 21, title: 'Exec 2 Governance Upcoming Deliverables & Hot Topics' },
    { row: 36, title: 'Admin & Settings - Quick Links' },
    { row: 47, title: 'KPIs & Performance Dashboards' },
    { row: 61, title: 'Executive Updates - Completed Hot Topics Archive' },
    { row: 161, title: 'Document Repository' },
    { row: 213, title: 'Exec 2\'s Completed Governance Items' }
  ];
  
  const columnHeaders = ['Description', 'ETA', 'Owner', 'Link to Materials', 'Days Left', '', 'Comment'];
  
  sections.forEach(section => {
    // Section title
    sheet.getRange(section.row, 1, 1, 7).merge()
      .setValue(section.title)
      .setFontWeight('bold')
      .setFontSize(12)
      .setBackground('#f3f4f6')
      .setHorizontalAlignment('left');
    
    // Column headers
    sheet.getRange(section.row + 1, 1, 1, columnHeaders.length)
      .setValues([columnHeaders])
      .setFontWeight('bold')
      .setBackground('#e5e7eb')
      .setHorizontalAlignment('center');
  });
  
  // Set column widths
  sheet.setColumnWidth(1, 300); // Description
  sheet.setColumnWidth(2, 100); // ETA
  sheet.setColumnWidth(3, 120); // Owner
  sheet.setColumnWidth(4, 250); // Link
  sheet.setColumnWidth(5, 100); // Days Left
  sheet.setColumnWidth(6, 50);  // Empty
  sheet.setColumnWidth(7, 250); // Comment
  
  Logger.log('‚úÖ Deliverables sheet initialized with section structure');
}

// ============================================================================
// CALENDAR SYNC FUNCTIONS
// ============================================================================

/**
 * Sync executive's calendar to Meetings sheet
 */
function syncCalendarToMeetingsSheet() {
  Logger.log('üîÑ Starting calendar sync...');
  
  const ss = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.MEETINGS_TAB_NAME);
  
  if (!sheet) {
    Logger.log('‚ùå Meetings sheet not found! Run ensureSheetsExist() first.');
    try {
      SpreadsheetApp.getUi().alert('‚ùå Meetings sheet not found!\n\nRun "Initialize Sheets" first.');
    } catch (e) {
      Logger.log('(Run ensureSheetsExist() function to create the sheet)');
    }
    return;
  }
  
  // Calculate date range
  const now = new Date();
  const startDate = new Date(now.getTime() - (CONFIG.SYNC_DAYS_BEHIND * 24 * 60 * 60 * 1000));
  const endDate = new Date(now.getTime() + (CONFIG.SYNC_DAYS_AHEAD * 24 * 60 * 60 * 1000));
  
  Logger.log(`üìÖ Syncing from ${startDate.toDateString()} to ${endDate.toDateString()}`);
  
  // Get calendar
  let calendar;
  try {
    if (CONFIG.EXECUTIVE_CALENDAR_ID === 'primary') {
      calendar = CalendarApp.getDefaultCalendar();
    } else {
      calendar = CalendarApp.getCalendarById(CONFIG.EXECUTIVE_CALENDAR_ID);
    }
  } catch (e) {
    Logger.log('‚ùå Error accessing calendar: ' + e);
    try {
      SpreadsheetApp.getUi().alert('‚ùå Cannot access calendar!\n\n' + e);
    } catch (uiError) {
      Logger.log('(Run from Google Sheets to see UI alerts)');
    }
    return;
  }
  
  // Get events
  const events = calendar.getEvents(startDate, endDate);
  Logger.log(`üìä Found ${events.length} calendar events`);
  
  // Get existing data to preserve manual edits
  const existingData = getExistingMeetingData(sheet);
  
  // Process events
  const newRows = [];
  for (const event of events) {
    const title = event.getTitle();
    
    // Skip all-day events
    if (event.isAllDayEvent()) {
      continue;
    }
    
    // Skip noisy meetings (DNS, lunch, 1:1, no attendees, no virtual link)
    if (shouldFilterMeeting(event, title)) {
      continue;
    }
    
    // Get event details
    const startTime = event.getStartTime();
    const endTime = event.getEndTime();
    const duration = Math.round((endTime - startTime) / (1000 * 60)); // minutes
    
    // Skip 0-minute meetings
    if (duration <= 0) continue;
    
    // Get description
    const description = event.getDescription() || '';
    const location = event.getLocation() || '';
    
    const eventId = event.getId();
    const existingRow = existingData[eventId];
    
    // Get attendees (limit to first 5)
    const guests = event.getGuestList();
    const attendees = guests.slice(0, 5)
      .map(g => g.getName() || g.getEmail().split('@')[0])
      .join(', ');
    
    // Clean description - remove HTML formatting
    const cleanDescription = cleanHtmlDescription(description);
    
    // Determine meeting type and frequency
    const meetingType = determineMeetingType(title);
    const frequency = determineFrequency(event, title);
    
    // Build row - preserve checkbox states if meeting exists
    const row = [
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.COMPLETE] : false,        // A: Complete
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.APPROVED] : false,        // B: Approved
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.HOT_TOPIC] : false,       // C: Hot Topic
      title,                                                                       // D: Meeting Name
      startTime,                                                                   // E: Date
      Utilities.formatDate(startTime, Session.getScriptTimeZone(), 'HH:mm'),     // F: Time
      duration + ' min',                                                           // G: Duration
      frequency,                                                                   // H: Frequency
      meetingType,                                                                 // I: Category
      cleanDescription,                                                            // J: Description
      attendees,                                                                   // K: Attendees
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] : '',   // L: Deliverable Link
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.PREP_REQUIRED] : false,   // M: Prep Required
      '',                                                                          // N: Empty column
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.NOTES] : '',              // O: Notes
      eventId                                                                      // P: Event ID
    ];
    
    newRows.push(row);
  }
  
  // Clear existing data (except header)
  if (sheet.getLastRow() > 1) {
    sheet.getRange(2, 1, sheet.getLastRow() - 1, 16).clearContent();
  }
  
  // Write new data
  if (newRows.length > 0) {
    sheet.getRange(2, 1, newRows.length, 16).setValues(newRows);
  }
  
  Logger.log(`‚úÖ Sync complete! ${newRows.length} meetings synced`);
  try {
    SpreadsheetApp.getUi().alert(`‚úÖ Calendar Sync Complete!\n\n${newRows.length} meetings synced\nFrom: ${startDate.toDateString()}\nTo: ${endDate.toDateString()}`);
  } catch (e) {
    Logger.log('(Sync complete - view results in the sheet)');
  }
}

/**
 * Get existing meeting data to preserve manual edits
 */
function getExistingMeetingData(sheet) {
  const data = {};
  if (sheet.getLastRow() < 2) return data;
  
  const range = sheet.getRange(2, 1, sheet.getLastRow() - 1, 16);
  const values = range.getValues();
  
  values.forEach(row => {
    const eventId = row[CONFIG.MEETING_COLUMNS.EVENT_ID];
    if (eventId) {
      data[eventId] = row;
    }
  });
  
  return data;
}

/**
 * Determine meeting type from title
 */
function determineMeetingType(title) {
  const titleLower = title.toLowerCase();
  
  if (titleLower.includes('1:1') || titleLower.includes('one on one')) return '1:1';
  if (titleLower.includes('staff') || titleLower.includes('team')) return 'Staff Meeting';
  if (titleLower.includes('board') || titleLower.includes('executive')) return 'Executive';
  if (titleLower.includes('standup') || titleLower.includes('daily')) return 'Standup';
  if (titleLower.includes('review') || titleLower.includes('retrospective')) return 'Review';
  if (titleLower.includes('planning')) return 'Planning';
  if (titleLower.includes('sync')) return 'Sync';
  if (titleLower.includes('deep work') || titleLower.includes('focus')) return 'Deep Work';
  
  return 'Meeting';
}

/**
 * Determine frequency from event
 */
function determineFrequency(event, title) {
  const titleLower = title.toLowerCase();
  
  if (titleLower.includes('daily')) return 'Daily';
  if (titleLower.includes('weekly')) return 'Weekly';
  if (titleLower.includes('biweekly') || titleLower.includes('bi-weekly')) return 'Bi-weekly';
  if (titleLower.includes('monthly')) return 'Monthly';
  if (titleLower.includes('quarterly')) return 'Quarterly';
  
  // Check if it's a recurring event
  // Note: EventRecurrence is not directly accessible in Apps Script
  // This is a simplified check
  return 'One-time';
}

/**
 * Check if event is non-meeting (OOO, holiday, DNS, lunch, 1:1, etc.)
 */
function isNonMeetingEvent(title) {
  const titleLower = title.toLowerCase();
  const nonMeetingKeywords = [
    'ooo', 'out of office', 'vacation', 'pto', 'holiday',
    'off', 'personal', 'dentist', 'doctor', 'appointment',
    'dns', 'do not schedule', 'lunch', 'break', 'blocked', 'hold',
    '1:1', '1-1', 'one on one', 'one-on-one', '1 on 1',
    'focus time', 'no meetings'
  ];
  
  return nonMeetingKeywords.some(keyword => titleLower.includes(keyword));
}

/**
 * Check if meeting should be filtered out (no attendees or no virtual link)
 */
function shouldFilterMeeting(event, title) {
  // First check title-based filters (DNS, Lunch, OOO, etc.)
  if (isNonMeetingEvent(title)) {
    return true;
  }
  
  // Rule for Attendees and Virtual Links has been removed.
  // All other events will now be synced to the sheet.
  return false;
}

/**
 * Clean HTML formatting from description
 */
function cleanHtmlDescription(html) {
  if (!html) return '';
  
  // Remove HTML tags but keep the text content
  let cleaned = html
    // Remove <br>, <br/>, <br /> tags with newlines
    .replace(/<br\s*\/?>/gi, '\n')
    // Remove HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    // Remove multiple spaces
    .replace(/\s+/g, ' ')
    // Remove multiple newlines
    .replace(/\n\s*\n/g, '\n')
    // Trim
    .trim();
  
  // Limit length to avoid cell overflow (max 500 chars)
  if (cleaned.length > 500) {
    cleaned = cleaned.substring(0, 497) + '...';
  }
  
  return cleaned;
}

/**
 * Setup daily automatic calendar sync
 */
function setupDailySyncTrigger() {
  // Remove existing triggers first
  removeSyncTriggers();
  
  // Create new daily trigger at 6 AM
  ScriptApp.newTrigger('syncCalendarToMeetingsSheet')
    .timeBased()
    .atHour(6)
    .everyDays(1)
    .create();
  
  Logger.log('‚úÖ Daily sync trigger created (6 AM daily)');
  try {
    SpreadsheetApp.getUi().alert('‚úÖ Automatic Daily Sync Enabled!\n\nCalendar will sync every day at 6 AM.\n\nTo disable, run "Remove Auto-Sync" from the menu.');
  } catch (e) {
    Logger.log('(Trigger created successfully - check Triggers in Apps Script)');
  }
}

/**
 * Remove all sync triggers
 */
function removeSyncTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  let removed = 0;
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'syncCalendarToMeetingsSheet') {
      ScriptApp.deleteTrigger(trigger);
      removed++;
    }
  });
  Logger.log(`‚úÖ Removed ${removed} sync trigger(s)`);
  try {
    if (removed > 0) {
      SpreadsheetApp.getUi().alert(`‚úÖ Auto-sync disabled!\n\n${removed} trigger(s) removed.`);
    } else {
      SpreadsheetApp.getUi().alert('‚ÑπÔ∏è No auto-sync triggers found.');
    }
  } catch (e) {
    Logger.log('(Triggers removed - view in Apps Script > Triggers)');
  }
}

// ============================================================================
// WEB APP FUNCTIONS
// ============================================================================

/**
 * Serves the HTML dashboard
 */
function doGet(e) {
  const template = HtmlService.createTemplateFromFile('index');
  return template.evaluate()
    .setTitle('Value Governance Dashboard')
    .setFaviconUrl('https://ssl.gstatic.com/docs/spreadsheets/favicon3.ico')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1.0');
}

/**
 * Include HTML files
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

// ============================================================================
// DATA RETRIEVAL FUNCTIONS
// ============================================================================

/**
 * Get all dashboard data in one call
 */
function getAllDashboardData() {
  try {
    Logger.log('Starting getAllDashboardData...');
    
    const result = {
      exec1Deliverables: [],
      exec2Deliverables: [],
      meetings: [],
      recurringMeetings: [],
      adminLinks: [],
      kpiLinks: [],
      executiveUpdates: [],
      documentRepository: [],
      documentRepoLinks: [],
      completedItems: []
    };
    
    // Get each section with individual error handling
    try {
      result.exec1Deliverables = getExec1Deliverables();
      Logger.log('‚úÖ Exec1: ' + result.exec1Deliverables.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec1: ' + e);
    }
    
    try {
      result.exec2Deliverables = getExec2Deliverables();
      Logger.log('‚úÖ Exec2: ' + result.exec2Deliverables.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec2: ' + e);
    }
    
    try {
      result.meetings = getMeetings();
      Logger.log('‚úÖ Meetings: ' + result.meetings.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Meetings: ' + e);
      Logger.log('Full error: ' + e.stack);
    }
    
    try {
      result.recurringMeetings = getRecurringMeetings();
      Logger.log('‚úÖ Recurring: ' + result.recurringMeetings.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Recurring: ' + e);
    }
    
    try {
      result.adminLinks = getAdminLinks();
      Logger.log('‚úÖ Admin: ' + result.adminLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Admin: ' + e);
    }
    
    try {
      result.kpiLinks = getKPILinks();
      Logger.log('‚úÖ KPI: ' + result.kpiLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting KPI: ' + e);
    }
    
    try {
      result.executiveUpdates = getExecutiveUpdates();
      Logger.log('‚úÖ Exec Updates: ' + result.executiveUpdates.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec Updates: ' + e);
    }
    
    try {
      result.documentRepository = getDocumentRepository();
      Logger.log('‚úÖ Documents: ' + result.documentRepository.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Documents: ' + e);
    }
    
    try {
      result.documentRepoLinks = getDocumentRepoLinks();
      Logger.log('‚úÖ Doc Repo Links: ' + result.documentRepoLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Doc Repo Links: ' + e);
    }
    
    try {
      result.completedItems = getCompletedItems();
      Logger.log('‚úÖ Completed: ' + result.completedItems.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Completed: ' + e);
    }
    
    Logger.log('Returning data...');
    
    // *** CRITICAL FIX: Force JSON serialization to strip out problematic Date objects ***
    const jsonSafeData = JSON.parse(JSON.stringify(result));
    return jsonSafeData;
    
  } catch (error) {
    Logger.log('‚ùå‚ùå‚ùå CRITICAL ERROR in getAllDashboardData: ' + error);
    Logger.log('Stack: ' + error.stack);
    return { 
      error: error.toString(),
      exec1Deliverables: [],
      exec2Deliverables: [],
      meetings: [],
      recurringMeetings: [],
      adminLinks: [],
      kpiLinks: [],
      executiveUpdates: [],
      documentRepository: [],
      documentRepoLinks: [],
      completedItems: []
    };
  }
}

/**
 * Simple test function to verify backend connection
 */
function testConnection() {
  return {
    status: 'success',
    message: 'Backend is working!',
    timestamp: new Date().toISOString(),
    sheetId: CONFIG.DELIVERABLES_SHEET_ID
  };
}

/**
 * Test if getAllDashboardData can be serialized
 */
function testSerializability() {
  try {
    const data = getAllDashboardData();
    const jsonString = JSON.stringify(data);
    
    return {
      success: true,
      dataSize: jsonString.length,
      itemCounts: {
        exec1: data.exec1Deliverables.length,
        exec2: data.exec2Deliverables.length,
        meetings: data.meetings.length,
        recurring: data.recurringMeetings.length,
        admin: data.adminLinks.length,
        kpi: data.kpiLinks.length,
        updates: data.executiveUpdates.length,
        documents: data.documentRepository.length,
        completed: data.completedItems.length
      }
    };
  } catch (e) {
    return {
      success: false,
      error: e.toString(),
      stack: e.stack
    };
  }
}

/**
 * Archive completed meetings to separate sheet
 */
function archiveCompletedMeetings() {
  const sheet = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).getSheetByName('Meetings');
  let archive = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).getSheetByName('Meeting Archive');
  
  if (!archive) {
    archive = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).insertSheet('Meeting Archive');
    archive.getRange(1, 1, 1, 16).setValues([sheet.getRange(1, 1, 1, 16).getValues()[0]]);
    archive.getRange(1, 1, 1, 16).setFontWeight('bold').setBackground('#1e293b').setFontColor('#ffffff');
  }
  
  const data = sheet.getDataRange().getValues();
  const toArchive = [];
  const toDelete = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === true) { // COMPLETE checkbox
      toArchive.push(data[i]);
      toDelete.push(i + 1);
    }
  }
  
  if (toArchive.length > 0) {
    const lastRow = archive.getLastRow();
    archive.getRange(lastRow + 1, 1, toArchive.length, 16).setValues(toArchive);
    
    for (let i = toDelete.length - 1; i >= 0; i--) {
      sheet.deleteRow(toDelete[i]);
    }
    
    Logger.log('‚úÖ Archived ' + toArchive.length + ' completed meetings');
    try {
      SpreadsheetApp.getUi().alert('‚úÖ Archived ' + toArchive.length + ' completed meetings');
    } catch (e) {
      Logger.log('Alert not available in this context');
    }
  } else {
    Logger.log('No completed meetings to archive');
    try {
      SpreadsheetApp.getUi().alert('No completed meetings to archive');
    } catch (e) {
      Logger.log('Alert not available in this context');
    }
  }
}

/**
 * Get Exec 1 Deliverables (DYNAMIC - stops at first empty row)
 */
function getExec1Deliverables() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.EXEC1_START_ROW;
    const maxRows = CONFIG.EXEC1_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const deliverables = [];
    const today = new Date();
    
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      const eta = row[1] ? new Date(row[1]) : null;
      const daysRemaining = eta ? Math.ceil((eta - today) / (1000 * 60 * 60 * 24)) : null;
      
      // Extract URL from Column D hyperlink
      let linkedMaterials = '';
      const richText = richTextValues[i][3];
      if (richText) {
        linkedMaterials = richText.getLinkUrl() || '';
      }
      if (!linkedMaterials && row[3]) {
        linkedMaterials = String(row[3]);
      }
      
      deliverables.push({
        id: 'exec1-' + i,
        description: row[0] || '',
        eta: eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'MMM dd') : '',
        etaFull: eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'yyyy-MM-dd') : '',
        owner: row[2] || '',
        linkedMaterials: linkedMaterials,
        daysRemaining: daysRemaining,
        daysRemainingText: daysRemaining !== null ? Math.abs(daysRemaining) + 'd' : '',
        comment: row[6] || '',
        isHotTopic: daysRemaining !== null && daysRemaining <= 7,
        isOverdue: daysRemaining !== null && daysRemaining < 0,
        urgency: getUrgencyLevel(daysRemaining)
      });
    }
    
    return deliverables;
  } catch (error) {
    Logger.log('Error getting Exec 1 deliverables: ' + error);
    return [];
  }
}

/**
 * Get Exec 2 Deliverables (DYNAMIC)
 */
function getExec2Deliverables() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.EXEC2_START_ROW;
    const maxRows = CONFIG.EXEC2_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const deliverables = [];
    const today = new Date();
    
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      const eta = row[1] ? new Date(row[1]) : null;
      const daysRemaining = eta ? Math.ceil((eta - today) / (1000 * 60 * 60 * 24)) : null;
      
      // Extract URL from Column D hyperlink
      let linkedMaterials = '';
      const richText = richTextValues[i][3];
      if (richText) {
        linkedMaterials = richText.getLinkUrl() || '';
      }
      if (!linkedMaterials && row[3]) {
        linkedMaterials = String(row[3]);
      }
      
      deliverables.push({
        id: 'exec2-' + i,
        description: row[0] || '',
        eta: eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'MMM dd') : '',
        etaFull: eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'yyyy-MM-dd') : '',
        owner: row[2] || '',
        linkedMaterials: linkedMaterials,
        daysRemaining: daysRemaining,
        daysRemainingText: daysRemaining !== null ? Math.abs(daysRemaining) + 'd' : '',
        comment: row[6] || '',
        isHotTopic: daysRemaining !== null && daysRemaining <= 7,
        isOverdue: daysRemaining !== null && daysRemaining < 0,
        urgency: getUrgencyLevel(daysRemaining)
      });
    }
    
    return deliverables;
  } catch (error) {
    Logger.log('Error getting Exec 2 deliverables: ' + error);
    return [];
  }
}

/**
 * Get meetings for 2-week schedule view
 */
function getMeetings() {
  try {
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (sheet.getLastRow() < 2) return [];
    
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const twoWeeksLater = new Date(today);
    twoWeeksLater.setDate(today.getDate() + 14);
    
    const meetings = [];
    
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      if (!row[CONFIG.MEETING_COLUMNS.MEETING_NAME]) continue;
      
      // Skip completed meetings
      if (row[CONFIG.MEETING_COLUMNS.COMPLETE] === true) continue;
      
      // ONLY show approved meetings
      if (row[CONFIG.MEETING_COLUMNS.APPROVED] !== true) continue;
      
      // CLEAN DATA: Filter out noisy meetings
      const title = (row[CONFIG.MEETING_COLUMNS.MEETING_NAME] || '').toLowerCase();
      const attendees = row[CONFIG.MEETING_COLUMNS.ATTENDEES] || '';
      const link = row[CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] || '';
      const description = (row[CONFIG.MEETING_COLUMNS.DESCRIPTION] || '').toLowerCase();
      
      // 1. Remove meetings with no attendees AND no meeting link
      const hasLink = link.includes('http') || description.includes('webex') || description.includes('zoom') || description.includes('meet.google');
      if (!attendees && !hasLink) continue;
      
      // 2. Remove lunch, DNS, and 1:1s
      if (title.includes('lunch') || title.includes('dns') || title.includes('1:1')) continue;
      
      const meetingDate = new Date(row[CONFIG.MEETING_COLUMNS.DATE]);
      const dayOfWeek = meetingDate.getDay();
      
      // Skip weekends (0 = Sunday, 6 = Saturday)
      if (dayOfWeek === 0 || dayOfWeek === 6) continue;

      if (meetingDate >= today && meetingDate <= twoWeeksLater) {
        meetings.push({
          id: row[CONFIG.MEETING_COLUMNS.EVENT_ID] || 'meeting-' + i,
          title: row[CONFIG.MEETING_COLUMNS.MEETING_NAME] || '',
          date: Utilities.formatDate(meetingDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
          dateFormatted: Utilities.formatDate(meetingDate, Session.getScriptTimeZone(), 'MMM dd'),
          time: (function(t) {
            if (!t) return '';
            let timeStr = String(t);
            // If it's a Date object from Sheets, format it
            if (t instanceof Date) {
              return Utilities.formatDate(t, Session.getScriptTimeZone(), 'h:mm a');
            }
            // If it's a string like "14:00", convert to 12h
            if (/^\d{1,2}:\d{2}/.test(timeStr)) {
              let [h, m] = timeStr.split(':');
              h = parseInt(h);
              let ampm = h >= 12 ? 'PM' : 'AM';
              h = h % 12;
              h = h ? h : 12;
              return h + ':' + m.substring(0,2) + ' ' + ampm;
            }
            return timeStr;
          })(row[CONFIG.MEETING_COLUMNS.TIME]),
          duration: String(row[CONFIG.MEETING_COLUMNS.DURATION] || ''),
          category: row[CONFIG.MEETING_COLUMNS.CATEGORY] || 'meeting',
          description: row[CONFIG.MEETING_COLUMNS.DESCRIPTION] || '',
          attendees: row[CONFIG.MEETING_COLUMNS.ATTENDEES] || '',
          isHotTopic: row[CONFIG.MEETING_COLUMNS.HOT_TOPIC] === true,
          prepRequired: row[CONFIG.MEETING_COLUMNS.PREP_REQUIRED] === true,
          deliverableLink: row[CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] || '',
          notes: row[CONFIG.MEETING_COLUMNS.NOTES] || '',
          dayOfWeek: meetingDate.getDay()
        });
      }
    }
    
    // Sort by date and time
    meetings.sort((a, b) => {
      const dateCompare = a.date.localeCompare(b.date);
      if (dateCompare !== 0) return dateCompare;
      
      // Compare times as strings (format: "HH:mm")
      const timeA = a.time || '00:00';
      const timeB = b.time || '00:00';
      return timeA.localeCompare(timeB);
    });
    
    return meetings;
  } catch (error) {
    Logger.log('Error getting meetings: ' + error);
    return [];
  }
}

/**
 * Get recurring meetings for agenda builder
 */
function getRecurringMeetings() {
  try {
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (sheet.getLastRow() < 2) return [];
    
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    const recurringMeetings = [];
    const seen = new Set();
    
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      const frequency = row[CONFIG.MEETING_COLUMNS.FREQUENCY] ? row[CONFIG.MEETING_COLUMNS.FREQUENCY].toString().toLowerCase() : '';
      const meetingName = row[CONFIG.MEETING_COLUMNS.MEETING_NAME];
      
      if (meetingName && frequency && 
          (frequency.includes('weekly') || frequency.includes('monthly') || 
           frequency.includes('daily') || frequency.includes('bi-weekly'))) {
        
        const key = meetingName.toString().trim();
        if (!seen.has(key)) {
          seen.add(key);
          recurringMeetings.push({
            id: row[CONFIG.MEETING_COLUMNS.EVENT_ID] || 'recurring-' + i,
            name: meetingName,
            frequency: row[CONFIG.MEETING_COLUMNS.FREQUENCY]
          });
        }
      }
    }
    
    return recurringMeetings;
  } catch (error) {
    Logger.log('Error getting recurring meetings: ' + error);
    return [];
  }
}

/**
 * Get Admin Links (DYNAMIC)
 */
function getAdminLinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.ADMIN_START_ROW;
    const maxRows = CONFIG.ADMIN_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'admin-' + i,
        name: String(row[0] || ''),
        url: url,
        category: 'admin'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting admin links: ' + error);
    return [];
  }
}

/**
 * Get KPI Links (DYNAMIC)
 */
function getKPILinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.KPI_START_ROW;
    const maxRows = CONFIG.KPI_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'kpi-' + i,
        name: String(row[0] || ''),
        url: url,
        category: 'kpi'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting KPI links: ' + error);
    return [];
  }
}

/**
 * Get Executive Updates (DYNAMIC)
 */
function getExecutiveUpdates() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.EXEC_UPDATES_START_ROW;
    const maxRows = CONFIG.EXEC_UPDATES_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const updates = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      updates.push({
        id: 'update-' + i,
        name: String(row[0] || ''),
        url: url,
        dateAdded: row[1] ? Utilities.formatDate(new Date(row[1]), Session.getScriptTimeZone(), 'MMM dd, yyyy') : '',
        category: 'executive-update'
      });
    }
    
    return updates;
  } catch (error) {
    Logger.log('Error getting executive updates: ' + error);
    return [];
  }
}

/**
 * Get Document Repository items (DYNAMIC) - NEW SECTION!
 */
function getDocumentRepository() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.DOCUMENTS_START_ROW;
    const maxRows = CONFIG.DOCUMENTS_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    
    const documents = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Safely handle date formatting
      let dateAdded = '';
      try {
        if (row[1] && row[1] instanceof Date) {
          dateAdded = Utilities.formatDate(row[1], Session.getScriptTimeZone(), 'MMM dd, yyyy');
        } else if (row[1]) {
          dateAdded = row[1].toString();
        }
      } catch (e) {
        Logger.log('Warning: Invalid date in Document Repository row ' + (startRow + i));
      }
      
      documents.push({
        id: 'document-' + i,
        name: String(row[0] || ''),
        url: String(row[3] || ''),
        dateAdded: dateAdded,
        owner: String(row[2] || ''),
        category: 'document'
      });
    }
    
    return documents;
  } catch (error) {
    Logger.log('Error getting document repository: ' + error);
    return [];
  }
}

/**
 * Get Completed Items (function getCompletedItems() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.COMPLETED_START_ROW;
    const maxRows = CONFIG.COMPLETED_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    
    const completed = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      completed.push({
        id: 'completed-' + i,
        description: row[0],
        eta: row[1] instanceof Date ? Utilities.formatDate(row[1], Session.getScriptTimeZone(), 'MMM dd') : row[1],
        owner: row[2],
        link: row[3],
        daysLeft: row[4],
        comment: row[6]
      });
    }
    return completed;
  } catch (error) {
    Logger.log('Error getting completed items: ' + error);
    return [];
  }
}

/**
 * Get active alerts for the scrolling banner
 */
function getAlerts() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.ALERT_SHEET_NAME);
    if (!sheet) return [];
    
    const data = sheet.getDataRange().getValues();
    const alerts = [];
    
    // Column A: Active (Checkbox), Column B: Alert Text
    for (let i = CONFIG.ALERT_START_ROW - 1; i < data.length; i++) {
      if (data[i][0] === true && data[i][1]) {
        alerts.push(data[i][1]);
      }
    }
    return alerts;
  } catch (error) {
    Logger.log('Error getting alerts: ' + error);
    return [];
  }
}
// ===========================================
// AGENDA CREATION FUNCTIONS
// ============================================================================

/**
 * Create agenda document
 */
function createAgenda(meetingData) {
  try {
    const { meetingName, meetingDate, topics, meetingLink } = meetingData;
    
    const doc = DocumentApp.create(`${meetingName} - Agenda - ${meetingDate}`);
    const body = doc.getBody();
    
    // Title
    const title = body.appendParagraph(meetingName);
    title.setHeading(DocumentApp.ParagraphHeading.HEADING1);
    title.setAlignment(DocumentApp.HorizontalAlignment.CENTER);
    
    // Date
    const dateP = body.appendParagraph(meetingDate);
    dateP.setAlignment(DocumentApp.HorizontalAlignment.CENTER);
    body.appendParagraph('');
    
    // Meeting link
    if (meetingLink) {
      const linkP = body.appendParagraph('Meeting Link: ');
      linkP.appendText(meetingLink).setLinkUrl(meetingLink);
      body.appendParagraph('');
    }
    
    // Agenda topics
    const topicsHeading = body.appendParagraph('Agenda Topics');
    topicsHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    
    topics.forEach((topic, index) => {
      if (topic && topic.trim() !== '') {
        const topicP = body.appendParagraph(`${index + 1}. ${topic}`);
        topicP.setIndentFirstLine(36);
        body.appendParagraph('   Notes:');
        body.appendParagraph('');
      }
    });
    
    // Action items
    body.appendParagraph('');
    const actionHeading = body.appendParagraph('Action Items');
    actionHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    body.appendParagraph('‚Ä¢ ');
    body.appendParagraph('‚Ä¢ ');
    body.appendParagraph('‚Ä¢ ');
    
    // Next steps
    body.appendParagraph('');
    const nextStepsHeading = body.appendParagraph('Next Steps');
    nextStepsHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    body.appendParagraph('');
    
    doc.saveAndClose();
    
    return {
      success: true,
      documentUrl: doc.getUrl(),
      documentId: doc.getId(),
      documentName: doc.getName()
    };
    
  } catch (error) {
    Logger.log('Error creating agenda: ' + error);
    return {
      success: false,
      error: error.toString()
    };
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get sheet by ID and tab name
 */
function getSheet(sheetId, tabName) {
  const ss = SpreadsheetApp.openById(sheetId);
  return ss.getSheetByName(tabName);
}

/**
 * Calculate urgency level
 */
function getUrgencyLevel(daysRemaining) {
  if (daysRemaining === null) return 'none';
  if (daysRemaining < 0) return 'overdue';
  if (daysRemaining <= 5) return 'critical';
  if (daysRemaining <= 10) return 'high';
  if (daysRemaining <= 20) return 'medium';
  return 'low';
}

/**
 * Test function
 */
function testDataRetrieval() {
  Logger.log('Testing data retrieval...');
  Logger.log('Exec 1 Deliverables:', JSON.stringify(getExec1Deliverables(), null, 2));
  Logger.log('Meetings:', JSON.stringify(getMeetings(), null, 2));
  Logger.log('Recurring Meetings:', JSON.stringify(getRecurringMeetings(), null, 2));
}

// ============================================================================
// V8 NEW FUNCTIONS
// ============================================================================

/**
 * Get Document Repository Links (separate from main document list)
 */
function getDocumentRepoLinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.DOCUMENTS_START_ROW;
    const maxRows = CONFIG.DOCUMENTS_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'doc-repo-' + i,
        name: String(row[0] || ''),
        description: String(row[0] || ''),
        url: url,  // Column D
        link: url,  // Column D
        owner: String(row[2] || ''),
        comment: String(row[4] || ''),
        category: 'document-repo'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting document repo links: ' + error);
    return [];
  }
}

/**
 * Complete an item and move it to destination
 */
function completeItem(itemId, destination) {
  try {
    Logger.log('Completing item: ' + itemId + ' to ' + destination);
    
    // This is a placeholder - implement based on your sheet structure
    // You'll need to:
    // 1. Find the item by ID in the appropriate sheet section
    // 2. Copy it to the destination section
    // 3. Delete or mark it as complete in the source
    
    return { success: true, message: 'Item completed and moved to ' + destination };
    
  } catch (error) {
    Logger.log('Error completing item: ' + error);
    throw error;
  }
}

/**
 * Add new item to deliverables
 */
function addNewItem(itemData) {
  try {
    Logger.log('Adding new item to: ' + itemData.section);
    
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    
    // Determine target section
    let targetStartRow;
    if (itemData.section === 'exec1') {
      targetStartRow = CONFIG.EXEC1_START_ROW;
    } else if (itemData.section === 'exec2') {
      targetStartRow = CONFIG.EXEC2_START_ROW;
    } else {
      throw new Error('Unknown section: ' + itemData.section);
    }
    
    // Find first empty row in section
    let targetRow = targetStartRow;
    while (sheet.getRange(targetRow, 1).getValue() !== '') {
      targetRow++;
    }
    
    // Prepare row data (adjust columns based on your sheet structure)
    const rowData = [
      itemData.description,
      itemData.eta || '',
      itemData.owner || '',
      itemData.link || '',
      itemData.comments || '',
      itemData.isHotTopic ? 'YES' : ''
    ];
    
    // Insert data
    sheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
    
    return { success: true, message: 'Item added successfully' };
    
  } catch (error) {
    Logger.log('Error adding item: ' + error);
    throw error;
  }
}
// ============================================================================
// DELIVERABLE CRUD FUNCTIONS
// ============================================================================

/**
 * Update a deliverable item
 * @param {Object} data - Deliverable data including execType, itemIndex, and all fields
 * @return {Object} Success/error response
 */
function updateDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.SHEET_NAME };
    }
    
    // Determine the row range based on execType
    let startRow, endRow;
    if (data.execType === 'exec1') {
      startRow = CONFIG.EXEC1_START_ROW;
      endRow = CONFIG.EXEC1_END_ROW;
    } else if (data.execType === 'exec2') {
      startRow = CONFIG.EXEC2_START_ROW;
      endRow = CONFIG.EXEC2_END_ROW;
    } else {
      return { success: false, error: 'Invalid execType: ' + data.execType };
    }
    
    // Calculate actual row number
    const actualRow = startRow + data.itemIndex;
    
    if (actualRow > endRow) {
      return { success: false, error: 'Item index out of range' };
    }
    
    // Update the row
    // Assuming columns: A=Description, B=ETA, C=Owner, D=Link, E=HotTopic, F=Comments, G=LinkedMeetingId, H=MeetingType, I=DueDate
    const range = sheet.getRange(actualRow, 1, 1, 9);
    const values = [[
      data.description || '',
      data.eta || '',
      data.owner || '',
      data.link || '',
      data.hotTopic ? 'TRUE' : 'FALSE',
      data.comments || '',
      data.linkedMeetingId || '',
      data.meetingType || '',
      data.dueDate || ''
    ]];
    
    range.setValues(values);
    
    // Update hyperlink in Column D if provided
    if (data.link) {
      const linkCell = sheet.getRange(actualRow, 4); // Column D
      linkCell.setFormula('=HYPERLINK("' + data.link + '", "Link to File")');
    }
    
    Logger.log('‚úÖ Updated deliverable: ' + data.description);
    return { success: true, message: 'Deliverable updated successfully' };
    
  } catch (error) {
    Logger.log('‚ùå Error updating deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Delete a deliverable item
 * @param {Object} data - Contains execType and itemIndex
 * @return {Object} Success/error response
 */
function deleteDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.SHEET_NAME };
    }
    
    // Determine the row range based on execType
    let startRow, endRow;
    if (data.execType === 'exec1') {
      startRow = CONFIG.EXEC1_START_ROW;
      endRow = CONFIG.EXEC1_END_ROW;
    } else if (data.execType === 'exec2') {
      startRow = CONFIG.EXEC2_START_ROW;
      endRow = CONFIG.EXEC2_END_ROW;
    } else {
      return { success: false, error: 'Invalid execType: ' + data.execType };
    }
    
    // Calculate actual row number
    const actualRow = startRow + data.itemIndex;
    
    if (actualRow > endRow) {
      return { success: false, error: 'Item index out of range' };
    }
    
    // Clear the row (don't delete to preserve row numbers)
    const range = sheet.getRange(actualRow, 1, 1, 9);
    range.clearContent();
    
    Logger.log('‚úÖ Deleted deliverable at row: ' + actualRow);
    return { success: true, message: 'Deliverable deleted successfully' };
    
  } catch (error) {
    Logger.log('‚ùå Error deleting deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Add a new deliverable item
 * @param {Object} data - Deliverable data including execType and all fields
 * @return {Object} Success/error response
 */
function addDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.SPREADSHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.SHEET_NAME };
    }
    
    // Determine the row range based on execType
    let startRow, endRow;
    if (data.execType === 'exec1') {
      startRow = CONFIG.EXEC1_START_ROW;
      endRow = CONFIG.EXEC1_END_ROW;
    } else if (data.execType === 'exec2') {
      startRow = CONFIG.EXEC2_START_ROW;
      endRow = CONFIG.EXEC2_END_ROW;
    } else {
      return { success: false, error: 'Invalid execType: ' + data.execType };
    }
    
    // Find the first empty row in the range
    const range = sheet.getRange(startRow, 1, endRow - startRow + 1, 1);
    const values = range.getValues();
    let emptyRow = null;
    
    for (let i = 0; i < values.length; i++) {
      if (!values[i][0] || values[i][0].toString().trim() === '') {
        emptyRow = startRow + i;
        break;
      }
    }
    
    if (!emptyRow) {
      return { success: false, error: 'No empty rows available in ' + data.execType + ' section' };
    }
    
    // Add the new item
    const newRange = sheet.getRange(emptyRow, 1, 1, 9);
    const newValues = [[
      data.description || '',
      data.eta || '',
      data.owner || '',
      data.link || '',
      data.hotTopic ? 'TRUE' : 'FALSE',
      data.comments || '',
      data.linkedMeetingId || '',
      data.meetingType || '',
      data.dueDate || ''
    ]];
    
    newRange.setValues(newValues);
    
    // Set hyperlink in Column D if provided
    if (data.link) {
      const linkCell = sheet.getRange(emptyRow, 4); // Column D
      linkCell.setFormula('=HYPERLINK("' + data.link + '", "Link to File")');
    }
    
    Logger.log('‚úÖ Added new deliverable: ' + data.description + ' at row ' + emptyRow);
    return { success: true, message: 'Deliverable added successfully', row: emptyRow };
    
  } catch (error) {
    Logger.log('‚ùå Error adding deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}
