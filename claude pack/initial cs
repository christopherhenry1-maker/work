/**
 * ============================================================================
 * EXECUTIVE DASHBOARD - COMPLETE GOOGLE APPS SCRIPT
 * ============================================================================
 * VP of Value Brands - Executive Command Center
 * 
 * FEATURES:
 * - Auto-creates sheet tabs if they don't exist
 * - Syncs executive's Google Calendar to Meetings sheet
 * - Serves dashboard with real-time data
 * - Creates agenda documents
 * - Supports recurring meeting management
 * 
 * Version: 2.0 (Complete with Calendar Sync)
 * Last Updated: February 1, 2026
 * ============================================================================
 */

// ============================================================================
// CONFIGURATION - UPDATE THESE
// ============================================================================

const CONFIG = {
  // Main Sheet IDs
  DELIVERABLES_SHEET_ID: '1ZmC-04S_OdhuoJs-XIBiOujj5rtsJTZNOiH26_0LTgk',
  
  // If meetings are in same workbook, use same ID:
  MEETINGS_SHEET_ID: '1ZmC-04S_OdhuoJs-XIBiOujj5rtsJTZNOiH26_0LTgk',
  
  // Tab/Sheet Names (will be auto-created if missing)
  MEETINGS_TAB_NAME: 'Meetings',
  DELIVERABLES_TAB_NAME: 'Document Repository',
  ARCHIVE_TAB_NAME: 'Meeting Archive', // NEW - for completed meetings
  
  // Overview: "On the Radar" (manual input + Gemini weekly summary)
  RADAR_TAB_NAME: 'On the Radar',
  RADAR_COLUMNS: {
    DATE: 0,       // A
    STATEMENT: 1,  // B
    OWNER: 2,      // C
    TAGS: 3,       // D
    INCLUDE: 4     // E
  },
  RADAR_SUMMARY_CELL: 'G2',
  RADAR_LAST_UPDATED_CELL: 'G3',

  // Agenda tabs (Deep Dives + Judge's Table)
  AGENDA_SHEET_ID: '1ZmC-04S_OdhuoJs-XIBiOujj5rtsJTZNOiH26_0LTgk',
  AGENDA_TAB_NAMES: [
    'Marketing Deep Dives',
    'Brand Deep Dives',
    "Judge's Table"
  ],
  AGENDA_COLUMNS: {
    DATE: 0,          // Column A
    TOPIC_START: 1,   // Column B
    TOPIC_COUNT: 6,   // B, D, F, H, J, L
    TOPIC_STRIDE: 2,  // Each topic is followed by its duration
    LINK: 13          // Column N (Link to Deck)
  },
  
  // Calendar Settings for Auto-Sync
  EXECUTIVE_CALENDAR_ID: 'michael.sarcone@verizon.com',
  SYNC_DAYS_AHEAD: 90,      // Pull meetings 90 days forward
  SYNC_DAYS_BEHIND: 0,      // Do not pull past meetings
  
  // Row ranges for Document Repository sheet
  // 
  // ‚≠ê IMPORTANT: These ranges are FLEXIBLE!
  // The code uses DYNAMIC detection and stops at the first empty row.
  // You can add/remove rows freely - just update START_ROW if sections move.
  // END_ROW values are safety limits, not hard requirements.
  // 
  // ‚úÖ You CAN change section names in the sheet without breaking code
  // ‚úÖ You CAN add more rows without updating END_ROW
  // ‚úÖ You CAN move sections - just update START_ROW values below
  
  EXEC1_START_ROW: 3,          // Mike's/Sarcone's Deliverables (Skipping Title)
  EXEC1_END_ROW: 13,
  
  EXEC2_START_ROW: 27,         // DK's Governance Deliverables (Skipping Title)
  EXEC2_END_ROW: 37,
  
  ADMIN_START_ROW: 47,         // Admin & Settings Links (Skipping Title)
  ADMIN_END_ROW: 52,
  
  KPI_START_ROW: 57,           // KPIs & Performance (Skipping Title)
  KPI_END_ROW: 68,
  
  EXEC_UPDATES_START_ROW: 75,  // Executive Updates Archive (Skipping Title)
  EXEC_UPDATES_END_ROW: 120,
  
  DOCUMENTS_START_ROW: 161,    // Document Repository Section (Skipping Title)
  DOCUMENTS_END_ROW: 202,
  
  COMPLETED_START_ROW: 216,    // Completed Items (Skipping Title)
  COMPLETED_END_ROW: 219,
  
  // Alert Banner Settings
  ALERT_SHEET_NAME: 'Alerts',
  ALERT_START_ROW: 2,
  
  // Column indices for Meetings sheet (0-indexed)
  MEETING_COLUMNS: {
    COMPLETE: 0,         // A
    APPROVED: 1,         // B
    HOT_TOPIC: 2,        // C
    MEETING_NAME: 3,     // D
    DATE: 4,             // E
    TIME: 5,             // F
    DURATION: 6,         // G
    FREQUENCY: 7,        // H
    CATEGORY: 8,         // I
    DESCRIPTION: 9,      // J
    ATTENDEES: 10,       // K
    DELIVERABLE_LINK: 11,// L
    PREP_REQUIRED: 12,   // M
    COLOR_ID: 13,        // N (Event color or hot topic level)
    NOTES: 14,           // O
    EVENT_ID: 15         // P
  }
};

// ============================================================================
// MAIN FUNCTIONS
// ============================================================================

/**
 * Deliverables sections can grow without updating *_END_ROW. We treat end rows as safety
 * limits and prefer the next section's START_ROW as the true boundary.
 */
function getDeliverablesSectionBounds_(sectionKey) {
  let startRow = null;
  let endRow = null;
  if (sectionKey === 'exec1') {
    startRow = CONFIG.EXEC1_START_ROW;
    // End right before the next section's headers.
    endRow = (CONFIG.EXEC2_START_ROW || CONFIG.EXEC1_END_ROW) - 2;
  } else if (sectionKey === 'exec2') {
    startRow = CONFIG.EXEC2_START_ROW;
    endRow = (CONFIG.ADMIN_START_ROW || CONFIG.EXEC2_END_ROW) - 2;
  } else {
    startRow = null;
    endRow = null;
  }
  if (!startRow || !endRow || endRow < startRow) {
    // Fallback to configured ends.
    if (sectionKey === 'exec1') return { startRow: CONFIG.EXEC1_START_ROW, endRow: CONFIG.EXEC1_END_ROW };
    if (sectionKey === 'exec2') return { startRow: CONFIG.EXEC2_START_ROW, endRow: CONFIG.EXEC2_END_ROW };
    return { startRow: 1, endRow: 1 };
  }
  return { startRow: startRow, endRow: endRow };
}

/**
 * Setup function - Initializes sheets (run this first!)
 */
function setup() {
  ensureSheetsExist();
  Logger.log('‚úÖ Setup complete!');
  Logger.log('üìä Sheets verified/created');
  Logger.log('');
  Logger.log('üöÄ Next steps:');
  Logger.log('1. Refresh your Google Sheet to see the menu');
  Logger.log('2. Use menu: üìä Executive Dashboard > üîÑ Sync Calendar Now');
  Logger.log('3. Deploy as Web App (Deploy > New Deployment)');
}

/**
 * Create custom menu - called automatically when sheet opens
 */
function onOpen() {
  createCustomMenu();
}

/**
 * Create custom menu in Google Sheets
 */
function createCustomMenu() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üìä Executive Dashboard')
    .addItem('üîÑ Sync Calendar Now', 'syncCalendarToMeetingsSheet')
    .addItem('üìÖ Setup Daily Auto-Sync', 'setupDailySyncTrigger')
    .addItem('üóëÔ∏è Remove Auto-Sync', 'removeSyncTriggers')
    .addSeparator()
    .addItem('üß† Update On the Radar Summary (Gemini)', 'updateOnTheRadarSummary')
    .addSeparator()
    .addItem('üì¶ Archive Completed Meetings', 'archiveCompletedMeetings')
    .addSeparator()
    .addItem('üèóÔ∏è Initialize Sheets', 'ensureSheetsExist')
    .addItem('üß™ Test Data Retrieval', 'testDataRetrieval')
    .addToUi();
}

/**
 * Ensure all required sheets exist, create if missing
 */
function ensureSheetsExist() {
  const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
  
  let sheetsCreated = [];
  
  // Create Meetings sheet if missing
  let meetingsSheet = ss.getSheetByName(CONFIG.MEETINGS_TAB_NAME);
  if (!meetingsSheet) {
    Logger.log('üìù Creating Meetings sheet...');
    meetingsSheet = ss.insertSheet(CONFIG.MEETINGS_TAB_NAME);
    initializeMeetingsSheet(meetingsSheet);
    sheetsCreated.push(CONFIG.MEETINGS_TAB_NAME);
  } else {
    Logger.log('‚úÖ Meetings sheet already exists');
  }
  
  // Create Deliverables sheet if missing
  let deliverablesSheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
  if (!deliverablesSheet) {
    Logger.log('üìù Creating Team Updates sheet...');
    deliverablesSheet = ss.insertSheet(CONFIG.DELIVERABLES_TAB_NAME);
    initializeDeliverablesSheet(deliverablesSheet);
    sheetsCreated.push(CONFIG.DELIVERABLES_TAB_NAME);
  } else {
    Logger.log('‚úÖ Team Updates sheet already exists');
  }

  // Create On the Radar sheet if missing
  let radarSheet = ss.getSheetByName(CONFIG.RADAR_TAB_NAME);
  if (!radarSheet) {
    Logger.log('üìù Creating On the Radar sheet...');
    radarSheet = ss.insertSheet(CONFIG.RADAR_TAB_NAME);
    initializeOnTheRadarSheet(radarSheet);
    sheetsCreated.push(CONFIG.RADAR_TAB_NAME);
  } else {
    Logger.log('‚úÖ On the Radar sheet already exists');
  }

  // Ensure agenda tabs exist in the agenda workbook
  try {
    const agendaSs = SpreadsheetApp.openById(CONFIG.AGENDA_SHEET_ID);
    const agendaTabs = getAgendaTabNames_();
    agendaTabs.forEach(name => {
      let sh = agendaSs.getSheetByName(name);
      if (!sh) {
        sh = agendaSs.insertSheet(name);
        initializeAgendaTab_(sh);
        sheetsCreated.push('Agenda: ' + name);
      } else if (!isAgendaTabByHeader_(sh)) {
        // If the tab exists but doesn't have headers, don't overwrite data; just leave it.
        Logger.log('‚ÑπÔ∏è Agenda tab exists but headers not detected: ' + name);
      }
    });
  } catch (e) {
    Logger.log('‚ùå Error ensuring agenda tabs: ' + e);
  }
  
  // Show results
  if (sheetsCreated.length > 0) {
    Logger.log('‚úÖ Created sheets: ' + sheetsCreated.join(', '));
    // Try to show UI alert if possible, but don't fail if not
    try {
      SpreadsheetApp.getUi().alert('‚úÖ Sheets Created!\n\nNew sheets:\n‚Ä¢ ' + sheetsCreated.join('\n‚Ä¢ '));
    } catch (e) {
      Logger.log('(Running from script editor - UI alerts disabled)');
    }
  } else {
    Logger.log('‚úÖ All required sheets already exist');
    try {
      SpreadsheetApp.getUi().alert('‚úÖ All sheets verified!\n\nExisting sheets:\n‚Ä¢ ' + CONFIG.MEETINGS_TAB_NAME + '\n‚Ä¢ ' + CONFIG.DELIVERABLES_TAB_NAME);
    } catch (e) {
      Logger.log('(Running from script editor - UI alerts disabled)');
    }
  }
}

/**
 * Initialize Meetings sheet with headers
 */
function initializeMeetingsSheet(sheet) {
  const headers = [
    'COMPLETE', 'APPROVED', 'HOT TOPIC', 'MEETING NAME', 'DATE', 'TIME',
    'DURATION', 'FREQUENCY', 'CATEGORY', 'DESCRIPTION', 'ATTENDEES',
    'DELIVERABLE LINK', 'PREP REQUIRED', 'COLOR ID', 'NOTES', 'EVENT ID'
  ];
  
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length)
    .setFontWeight('bold')
    .setBackground('#1e293b')
    .setFontColor('#ffffff')
    .setHorizontalAlignment('center');
  
  // Set column widths
  sheet.setColumnWidth(1, 80);  // Complete
  sheet.setColumnWidth(2, 80);  // Approved
  sheet.setColumnWidth(3, 90);  // Hot Topic
  sheet.setColumnWidth(4, 250); // Meeting Name
  sheet.setColumnWidth(5, 100); // Date
  sheet.setColumnWidth(6, 80);  // Time
  sheet.setColumnWidth(7, 90);  // Duration
  sheet.setColumnWidth(8, 100); // Frequency
  sheet.setColumnWidth(9, 120); // Category
  sheet.setColumnWidth(10, 300);// Description
  sheet.setColumnWidth(11, 200);// Attendees
  sheet.setColumnWidth(12, 200);// Deliverable Link
  sheet.setColumnWidth(13, 110);// Prep Required
  sheet.setColumnWidth(14, 50); // Empty
  sheet.setColumnWidth(15, 250);// Notes
  sheet.setColumnWidth(16, 200);// Event ID
  
  // Format checkboxes
  sheet.getRange('A2:C1000').insertCheckboxes();
  sheet.getRange('M2:M1000').insertCheckboxes();
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  Logger.log('‚úÖ Meetings sheet initialized with headers and formatting');
}

/**
 * Initialize Deliverables sheet with section headers
 */
function initializeDeliverablesSheet(sheet) {
  const sections = [
    { row: 1, title: 'Mike\'s/Sarcone\'s Upcoming Deliverables & Hot Topics' },
    { row: 21, title: 'DK\'s Governance Upcoming Deliverables & Hot Topics' },
    { row: 36, title: 'Admin & Settings - Quick Links' },
    { row: 47, title: 'KPIs & Performance Dashboards' },
    { row: 61, title: 'Executive Updates - Completed Hot Topics Archive' },
    { row: 161, title: 'Document Repository' },
    { row: 213, title: 'DK\'s Completed Governance Items' }
  ];
  
  const columnHeaders = ['Description', 'ETA', 'Owner', 'Link to Materials', 'Days Left', '', 'Comment'];
  
  sections.forEach(section => {
    // Section title
    sheet.getRange(section.row, 1, 1, 7).merge()
      .setValue(section.title)
      .setFontWeight('bold')
      .setFontSize(12)
      .setBackground('#f3f4f6')
      .setHorizontalAlignment('left');
    
    // Column headers
    sheet.getRange(section.row + 1, 1, 1, columnHeaders.length)
      .setValues([columnHeaders])
      .setFontWeight('bold')
      .setBackground('#e5e7eb')
      .setHorizontalAlignment('center');
  });
  
  // Set column widths
  sheet.setColumnWidth(1, 300); // Description
  sheet.setColumnWidth(2, 100); // ETA
  sheet.setColumnWidth(3, 120); // Owner
  sheet.setColumnWidth(4, 250); // Link
  sheet.setColumnWidth(5, 100); // Days Left
  sheet.setColumnWidth(6, 50);  // Empty
  sheet.setColumnWidth(7, 250); // Comment
  
  Logger.log('‚úÖ Deliverables sheet initialized with section structure');
}

// ============================================================================
// CALENDAR SYNC FUNCTIONS
// ============================================================================

/**
 * Sync executive's calendar to Meetings sheet
 */
function syncCalendarToMeetingsSheet() {
  Logger.log('üîÑ Starting calendar sync...');
  
  const ss = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID);
  const sheet = ss.getSheetByName(CONFIG.MEETINGS_TAB_NAME);
  
  if (!sheet) {
    Logger.log('‚ùå Meetings sheet not found! Run ensureSheetsExist() first.');
    try {
      SpreadsheetApp.getUi().alert('‚ùå Meetings sheet not found!\n\nRun "Initialize Sheets" first.');
    } catch (e) {
      Logger.log('(Run ensureSheetsExist() function to create the sheet)');
    }
    return;
  }
  
  // Calculate date range
  const now = new Date();
  const startDate = new Date(now);
  startDate.setHours(0, 0, 0, 0);
  const endDate = new Date(now.getTime() + (CONFIG.SYNC_DAYS_AHEAD * 24 * 60 * 60 * 1000));
  
  Logger.log(`üìÖ Syncing from ${startDate.toDateString()} to ${endDate.toDateString()}`);
  
  // Get calendar
  let calendar;
  try {
    if (CONFIG.EXECUTIVE_CALENDAR_ID === 'primary') {
      calendar = CalendarApp.getDefaultCalendar();
    } else {
      calendar = CalendarApp.getCalendarById(CONFIG.EXECUTIVE_CALENDAR_ID);
    }
  } catch (e) {
    Logger.log('‚ùå Error accessing calendar: ' + e);
    try {
      SpreadsheetApp.getUi().alert('‚ùå Cannot access calendar!\n\n' + e);
    } catch (uiError) {
      Logger.log('(Run from Google Sheets to see UI alerts)');
    }
    return;
  }
  
  // Get events
  const events = calendar.getEvents(startDate, endDate);
  Logger.log(`üìä Found ${events.length} calendar events`);
  
  // Get existing data to preserve manual edits
  const existingData = getExistingMeetingData(sheet);
  
  // Process events
  const newRows = [];
  for (const event of events) {
    const title = event.getTitle();
    
    // Skip all-day events
    if (event.isAllDayEvent()) {
      continue;
    }
    
    // Skip noisy meetings (DNS, lunch, 1:1, no attendees, no virtual link)
    if (shouldFilterMeeting(event, title)) {
      continue;
    }
    
    // Get event details
    const startTime = event.getStartTime();
    const endTime = event.getEndTime();
    const duration = Math.round((endTime - startTime) / (1000 * 60)); // minutes
    
    // Skip past meetings (including earlier today)
    if (startTime < now) continue;
    
    // Skip 0-minute meetings
    if (duration <= 0) continue;
    
    // Get description
    const description = event.getDescription() || '';
    const location = event.getLocation() || '';
    
    const eventId = event.getId();
    const existingRow = existingData[eventId];
    
    // Get attendees (limit to first 5)
    const guests = event.getGuestList();
    const attendees = guests.slice(0, 5)
      .map(g => g.getName() || g.getEmail().split('@')[0])
      .join(', ');
    
    // Clean description - remove HTML formatting
    const cleanDescription = cleanHtmlDescription(description);
    
    // Determine meeting type and frequency
    const meetingType = determineMeetingType(title);
    const frequency = determineFrequency(event, title);
    
    // Determine hot topic based on color and keywords
    const hotTopicMeta = getHotTopicMeta(event, title, cleanDescription);
    const isAutoHotTopic = hotTopicMeta.isHotTopic === true;
    const hotTopicValue = isAutoHotTopic || (existingRow ? existingRow[CONFIG.MEETING_COLUMNS.HOT_TOPIC] === true : false);
    
    // Build row - preserve checkbox states if meeting exists
    const row = [
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.COMPLETE] : false,        // A: Complete
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.APPROVED] : false,        // B: Approved
      hotTopicValue,                                                             // C: Hot Topic
      title,                                                                       // D: Meeting Name
      startTime,                                                                   // E: Date
      Utilities.formatDate(startTime, Session.getScriptTimeZone(), 'HH:mm'),     // F: Time
      duration + ' min',                                                           // G: Duration
      frequency,                                                                   // H: Frequency
      meetingType,                                                                 // I: Category
      cleanDescription,                                                            // J: Description
      attendees,                                                                   // K: Attendees
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] : '',   // L: Deliverable Link
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.PREP_REQUIRED] : false,   // M: Prep Required
      hotTopicMeta.metaValue || '',                                               // N: Color ID / Hot Topic Level
      existingRow ? existingRow[CONFIG.MEETING_COLUMNS.NOTES] : '',              // O: Notes
      eventId                                                                      // P: Event ID
    ];
    
    newRows.push(row);
  }
  
  // Clear existing data (except header)
  if (sheet.getLastRow() > 1) {
    sheet.getRange(2, 1, sheet.getLastRow() - 1, 16).clearContent();
  }
  
  // Write new data
  if (newRows.length > 0) {
    sheet.getRange(2, 1, newRows.length, 16).setValues(newRows);
  }

  // Ensure checkbox formatting for A, B, C, and M columns
  const lastRow = Math.max(sheet.getLastRow(), 2);
  sheet.getRange(2, 1, lastRow - 1, 1).insertCheckboxes(); // A
  sheet.getRange(2, 2, lastRow - 1, 1).insertCheckboxes(); // B
  sheet.getRange(2, 3, lastRow - 1, 1).insertCheckboxes(); // C
  sheet.getRange(2, 13, lastRow - 1, 1).insertCheckboxes(); // M
  
  Logger.log(`‚úÖ Sync complete! ${newRows.length} meetings synced`);
  try {
    SpreadsheetApp.getUi().alert(`‚úÖ Calendar Sync Complete!\n\n${newRows.length} meetings synced\nFrom: ${startDate.toDateString()}\nTo: ${endDate.toDateString()}`);
  } catch (e) {
    Logger.log('(Sync complete - view results in the sheet)');
  }
}

/**
 * Get existing meeting data to preserve manual edits
 */
function getExistingMeetingData(sheet) {
  const data = {};
  if (sheet.getLastRow() < 2) return data;
  
  const range = sheet.getRange(2, 1, sheet.getLastRow() - 1, 16);
  const values = range.getValues();
  
  values.forEach(row => {
    const eventId = row[CONFIG.MEETING_COLUMNS.EVENT_ID];
    if (eventId) {
      data[eventId] = row;
    }
  });
  
  return data;
}

/**
 * Determine meeting type from title
 */
function determineMeetingType(title) {
  const titleLower = title.toLowerCase();
  
  if (titleLower.includes('1:1') || titleLower.includes('one on one')) return '1:1';
  if (titleLower.includes('staff') || titleLower.includes('team')) return 'Staff Meeting';
  if (titleLower.includes('board') || titleLower.includes('executive')) return 'Executive';
  if (titleLower.includes('standup') || titleLower.includes('daily')) return 'Standup';
  if (titleLower.includes('review') || titleLower.includes('retrospective')) return 'Review';
  if (titleLower.includes('planning')) return 'Planning';
  if (titleLower.includes('sync')) return 'Sync';
  if (titleLower.includes('deep work') || titleLower.includes('focus')) return 'Deep Work';
  
  return 'Meeting';
}

/**
 * Determine frequency from event
 */
function determineFrequency(event, title) {
  const titleLower = title.toLowerCase();
  
  if (titleLower.includes('daily')) return 'Daily';
  if (titleLower.includes('weekly')) return 'Weekly';
  if (titleLower.includes('biweekly') || titleLower.includes('bi-weekly')) return 'Bi-weekly';
  if (titleLower.includes('monthly')) return 'Monthly';
  if (titleLower.includes('quarterly')) return 'Quarterly';
  
  // Check if it's a recurring event
  // Note: EventRecurrence is not directly accessible in Apps Script
  // This is a simplified check
  return 'One-time';
}

/**
 * Check if event is non-meeting (OOO, holiday, DNS, lunch, 1:1, etc.)
 */
function isNonMeetingEvent(title) {
  const titleLower = title.toLowerCase();
  const nonMeetingKeywords = [
    'ooo', 'out of office', 'vacation', 'pto', 'holiday',
    'off', 'personal', 'dentist', 'doctor', 'appointment',
    'dns', 'do not schedule', 'lunch', 'break', 'blocked', 'hold',
    '1:1', '1-1', 'one on one', 'one-on-one', '1 on 1',
    'focus time', 'no meetings'
  ];
  
  return nonMeetingKeywords.some(keyword => titleLower.includes(keyword));
}

/**
 * Check if meeting should be filtered out (no attendees or no virtual link)
 */
function shouldFilterMeeting(event, title) {
  // First check title-based filters (DNS, Lunch, OOO, etc.)
  if (isNonMeetingEvent(title)) {
    return true;
  }
  
  // Rule for Attendees and Virtual Links has been removed.
  // All other events will now be synced to the sheet.
  return false;
}

function getEventColorIdSafe(event) {
  try {
    const color = event.getColor();
    if (color === CalendarApp.EventColor.ORANGE) return '6';
    if (color === CalendarApp.EventColor.RED) return '11';
    if (color === CalendarApp.EventColor.YELLOW) return '5';
    if (color === CalendarApp.EventColor.GREEN) return '10';
    if (color === CalendarApp.EventColor.BLUE) return '9';
    if (color === CalendarApp.EventColor.GRAY) return '8';
    if (color === CalendarApp.EventColor.PURPLE) return '7';
    if (color) return String(color);
  } catch (e) {
    Logger.log('Color lookup failed: ' + e);
  }
  return '';
}

function getHotTopicLevelFromText(title, description) {
  const text = ((title || '') + ' ' + (description || '')).toLowerCase();
  if (text.includes('urgent') || text.includes('critical')) return 'urgent';
  if (text.includes('must attend') || text.includes('must-attend')) return 'must-attend';
  return '';
}

function getHotTopicMeta(event, title, description) {
  const colorId = getEventColorIdSafe(event);
  let level = '';
  if (colorId === '11') level = 'urgent';
  if (colorId === '6') level = 'must-attend';
  
  if (!level) {
    level = getHotTopicLevelFromText(title, description);
  }
  
  const isHotTopic = level === 'urgent' || level === 'must-attend';
  const metaValue = colorId ? colorId : (level || '');
  return { isHotTopic: isHotTopic, level: level, metaValue: metaValue };
}

/**
 * Clean HTML formatting from description
 */
function cleanHtmlDescription(html) {
  if (!html) return '';
  
  // Remove HTML tags but keep the text content
  let cleaned = html
    // Remove <br>, <br/>, <br /> tags with newlines
    .replace(/<br\s*\/?>/gi, '\n')
    // Remove HTML tags
    .replace(/<[^>]+>/g, '')
    // Decode common HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    // Remove multiple spaces
    .replace(/\s+/g, ' ')
    // Remove multiple newlines
    .replace(/\n\s*\n/g, '\n')
    // Trim
    .trim();
  
  // Limit length to avoid cell overflow (max 500 chars)
  if (cleaned.length > 500) {
    cleaned = cleaned.substring(0, 497) + '...';
  }
  
  return cleaned;
}

/**
 * Setup daily automatic calendar sync
 */
function setupDailySyncTrigger() {
  // Remove existing triggers first
  removeSyncTriggers();
  
  // Create new daily trigger at 6 AM
  ScriptApp.newTrigger('syncCalendarToMeetingsSheet')
    .timeBased()
    .atHour(6)
    .everyDays(1)
    .create();
  
  Logger.log('‚úÖ Daily sync trigger created (6 AM daily)');
  try {
    SpreadsheetApp.getUi().alert('‚úÖ Automatic Daily Sync Enabled!\n\nCalendar will sync every day at 6 AM.\n\nTo disable, run "Remove Auto-Sync" from the menu.');
  } catch (e) {
    Logger.log('(Trigger created successfully - check Triggers in Apps Script)');
  }
}

/**
 * Remove all sync triggers
 */
function removeSyncTriggers() {
  const triggers = ScriptApp.getProjectTriggers();
  let removed = 0;
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'syncCalendarToMeetingsSheet') {
      ScriptApp.deleteTrigger(trigger);
      removed++;
    }
  });
  Logger.log(`‚úÖ Removed ${removed} sync trigger(s)`);
  try {
    if (removed > 0) {
      SpreadsheetApp.getUi().alert(`‚úÖ Auto-sync disabled!\n\n${removed} trigger(s) removed.`);
    } else {
      SpreadsheetApp.getUi().alert('‚ÑπÔ∏è No auto-sync triggers found.');
    }
  } catch (e) {
    Logger.log('(Triggers removed - view in Apps Script > Triggers)');
  }
}

/**
 * Initialize On the Radar sheet with headers and summary cells.
 */
function initializeOnTheRadarSheet(sheet) {
  const headers = ['Date', 'High-Level Statement', 'Owner', 'Tags', 'Include'];
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length)
    .setFontWeight('bold')
    .setBackground('#111827')
    .setFontColor('#ffffff')
    .setHorizontalAlignment('center');

  // Add Include checkboxes
  sheet.getRange(2, 5, 1000, 1).insertCheckboxes();

  // Summary area
  sheet.getRange('G1').setValue('Weekly Executive Summary (Gemini)')
    .setFontWeight('bold')
    .setBackground('#f3f4f6')
    .setHorizontalAlignment('left');
  sheet.getRange(CONFIG.RADAR_SUMMARY_CELL).setValue('Click: Executive Dashboard > Update On the Radar Summary (Gemini)')
    .setWrap(true);
  sheet.getRange(CONFIG.RADAR_LAST_UPDATED_CELL).setValue('')
    .setFontColor('#6b7280');

  // Layout
  sheet.setFrozenRows(1);
  sheet.setColumnWidth(1, 120); // Date
  sheet.setColumnWidth(2, 560); // Statement
  sheet.setColumnWidth(3, 160); // Owner
  sheet.setColumnWidth(4, 180); // Tags
  sheet.setColumnWidth(5, 90);  // Include
  sheet.setColumnWidth(7, 520); // Summary column

  // Wrap statement column and summary
  sheet.getRange(2, 2, 1000, 1).setWrap(true);
  sheet.getRange(CONFIG.RADAR_SUMMARY_CELL).setWrap(true);

  Logger.log('‚úÖ On the Radar sheet initialized');
}

// ============================================================================
// WEB APP FUNCTIONS
// ============================================================================

/**
 * Serves the HTML dashboard
 */
function doGet(e) {
  const template = HtmlService.createTemplateFromFile('index');
  return template.evaluate()
    .setTitle('Value Governance Dashboard')
    .setFaviconUrl('https://ssl.gstatic.com/docs/spreadsheets/favicon3.ico')
    .addMetaTag('viewport', 'width=device-width, initial-scale=1.0');
}

/**
 * Include HTML files
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

// ============================================================================
// DATA RETRIEVAL FUNCTIONS
// ============================================================================

function uniqStrings_(arr) {
  const out = [];
  const seen = {};
  (arr || []).forEach(v => {
    const s = String(v || '').trim();
    if (!s) return;
    const key = s.toLowerCase();
    if (seen[key]) return;
    seen[key] = true;
    out.push(s);
  });
  return out;
}

function isAgendaTabByHeader_(sheet) {
  try {
    if (!sheet) return false;
    const header = sheet.getRange(1, 1, 1, CONFIG.AGENDA_COLUMNS.LINK + 1).getDisplayValues()[0];
    if (!header || header.length < (CONFIG.AGENDA_COLUMNS.LINK + 1)) return false;
    const a = String(header[0] || '').toLowerCase();
    const b = String(header[1] || '').toLowerCase();
    const n = String(header[CONFIG.AGENDA_COLUMNS.LINK] || '').toLowerCase();
    return a.includes('date') && (b.includes('topic') || b.includes('agenda')) && (n.includes('link') || n.includes('deck'));
  } catch (e) {
    return false;
  }
}

function initializeAgendaTab_(sheet) {
  const headers = ['Date'];
  for (let i = 1; i <= CONFIG.AGENDA_COLUMNS.TOPIC_COUNT; i++) {
    headers.push('Topic ' + i);
    headers.push('Duration ' + i);
  }
  // Pad to Link column
  while (headers.length < CONFIG.AGENDA_COLUMNS.LINK + 1) headers.push('');
  headers[CONFIG.AGENDA_COLUMNS.LINK] = 'Link';
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  sheet.getRange(1, 1, 1, headers.length)
    .setFontWeight('bold')
    .setBackground('#111827')
    .setFontColor('#ffffff')
    .setHorizontalAlignment('center');
  sheet.setFrozenRows(1);
  sheet.setColumnWidth(1, 120);
  // Topic/Duration columns
  for (let c = 2; c <= (CONFIG.AGENDA_COLUMNS.LINK + 1); c++) {
    sheet.setColumnWidth(c, (c % 2 === 0) ? 320 : 120);
  }
  sheet.getRange(2, 1, 1000, headers.length).setWrap(true);
}

function getAgendaTabNames_() {
  const props = PropertiesService.getScriptProperties();
  let configured = [];
  try {
    const raw = props.getProperty('AGENDA_TAB_NAMES');
    if (raw) configured = JSON.parse(raw);
  } catch (e) {
    configured = [];
  }
  if (!Array.isArray(configured) || configured.length === 0) {
    configured = CONFIG.AGENDA_TAB_NAMES || [];
  }
  const ss = SpreadsheetApp.openById(CONFIG.AGENDA_SHEET_ID);
  const discovered = ss.getSheets()
    .filter(isAgendaTabByHeader_)
    .map(s => s.getName());
  const names = uniqStrings_([].concat(configured, discovered));
  try {
    props.setProperty('AGENDA_TAB_NAMES', JSON.stringify(names));
  } catch (e) {}
  return names;
}

/**
 * Get all dashboard data in one call
 */
function getAllDashboardData() {
  try {
    Logger.log('Starting getAllDashboardData...');
    
    const result = {
      exec1Deliverables: [],
      exec2Deliverables: [],
      meetings: [],
      agendaItems: [],
      agendaTypes: [],
      recurringMeetings: [],
      adminLinks: [],
      kpiLinks: [],
      executiveUpdates: [],
      documentRepository: [],
      documentRepoLinks: [],
      completedItems: [],
      onTheRadar: {
        summary: '',
        lastUpdated: '',
        items: []
      }
    };
    
    // Get each section with individual error handling
    try {
      result.exec1Deliverables = getExec1Deliverables();
      Logger.log('‚úÖ Exec1: ' + result.exec1Deliverables.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec1: ' + e);
    }
    
    try {
      result.exec2Deliverables = getExec2Deliverables();
      Logger.log('‚úÖ Exec2: ' + result.exec2Deliverables.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec2: ' + e);
    }
    
    try {
      result.meetings = getMeetings();
      Logger.log('‚úÖ Meetings: ' + result.meetings.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Meetings: ' + e);
      Logger.log('Full error: ' + e.stack);
    }

    try {
      result.agendaItems = getAgendaItems();
      Logger.log('‚úÖ Agendas: ' + result.agendaItems.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Agendas: ' + e);
    }

    try {
      result.agendaTypes = getAgendaTabNames_();
    } catch (e) {
      result.agendaTypes = CONFIG.AGENDA_TAB_NAMES || [];
    }
    
    try {
      result.recurringMeetings = getRecurringMeetings();
      Logger.log('‚úÖ Recurring: ' + result.recurringMeetings.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Recurring: ' + e);
    }
    
    try {
      result.adminLinks = getAdminLinks();
      Logger.log('‚úÖ Admin: ' + result.adminLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Admin: ' + e);
    }
    
    try {
      result.kpiLinks = getKPILinks();
      Logger.log('‚úÖ KPI: ' + result.kpiLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting KPI: ' + e);
    }
    
    try {
      result.executiveUpdates = getExecutiveUpdates();
      Logger.log('‚úÖ Exec Updates: ' + result.executiveUpdates.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Exec Updates: ' + e);
    }
    
    try {
      result.documentRepository = getDocumentRepository();
      Logger.log('‚úÖ Documents: ' + result.documentRepository.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Documents: ' + e);
    }
    
    try {
      result.documentRepoLinks = getDocumentRepoLinks();
      Logger.log('‚úÖ Doc Repo Links: ' + result.documentRepoLinks.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Doc Repo Links: ' + e);
    }
    
    try {
      result.completedItems = getCompletedItems();
      Logger.log('‚úÖ Completed: ' + result.completedItems.length + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting Completed: ' + e);
    }

    try {
      result.onTheRadar = getOnTheRadar();
      Logger.log('‚úÖ On the Radar: ' + (result.onTheRadar.items ? result.onTheRadar.items.length : 0) + ' items');
    } catch (e) {
      Logger.log('‚ùå Error getting On the Radar: ' + e);
    }
    
    Logger.log('Returning data...');
    
    // *** CRITICAL FIX: Force JSON serialization to strip out problematic Date objects ***
    const jsonSafeData = JSON.parse(JSON.stringify(result));
    return jsonSafeData;
    
  } catch (error) {
    Logger.log('‚ùå‚ùå‚ùå CRITICAL ERROR in getAllDashboardData: ' + error);
    Logger.log('Stack: ' + error.stack);
    return { 
      error: error.toString(),
      exec1Deliverables: [],
      exec2Deliverables: [],
      meetings: [],
      agendaItems: [],
      agendaTypes: [],
      recurringMeetings: [],
      adminLinks: [],
      kpiLinks: [],
      executiveUpdates: [],
      documentRepository: [],
      documentRepoLinks: [],
      completedItems: [],
      onTheRadar: { summary: '', lastUpdated: '', items: [] }
    };
  }
}

/**
 * Read On the Radar items + latest summary from the sheet.
 */
function getOnTheRadar() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.RADAR_TAB_NAME);
    if (!sheet) return { summary: '', lastUpdated: '', items: [] };

    const summary = String(sheet.getRange(CONFIG.RADAR_SUMMARY_CELL).getDisplayValue() || '').trim();
    let lastUpdated = String(sheet.getRange(CONFIG.RADAR_LAST_UPDATED_CELL).getDisplayValue() || '').trim();
    if (/^last updated\\s*:/i.test(lastUpdated)) {
      lastUpdated = lastUpdated.replace(/^last updated\\s*:/i, '').trim();
    }

    const lastRow = sheet.getLastRow();
    const items = [];
    if (lastRow >= 2) {
      const values = sheet.getRange(2, 1, lastRow - 1, 5).getValues();
      values.forEach(row => {
        const rawStatement = row[CONFIG.RADAR_COLUMNS.STATEMENT];
        const statement = rawStatement ? String(rawStatement).trim() : '';
        if (!statement) return;

        const includeVal = row[CONFIG.RADAR_COLUMNS.INCLUDE];
        if (includeVal === false) return;

        const rawDate = row[CONFIG.RADAR_COLUMNS.DATE];
        let dateKey = '';
        if (rawDate instanceof Date && !isNaN(rawDate.getTime())) {
          dateKey = Utilities.formatDate(rawDate, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        } else if (rawDate) {
          const parsed = new Date(rawDate);
          if (!isNaN(parsed.getTime())) {
            dateKey = Utilities.formatDate(parsed, Session.getScriptTimeZone(), 'yyyy-MM-dd');
          } else {
            dateKey = String(rawDate).trim();
          }
        }

        items.push({
          date: dateKey,
          statement: statement,
          owner: String(row[CONFIG.RADAR_COLUMNS.OWNER] || '').trim(),
          tags: String(row[CONFIG.RADAR_COLUMNS.TAGS] || '').trim()
        });
      });
    }

    return { summary: summary, lastUpdated: lastUpdated, items: items };
  } catch (error) {
    Logger.log('Error getting On the Radar: ' + error);
    return { summary: '', lastUpdated: '', items: [] };
  }
}

function getWeekRange_(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  const day = d.getDay(); // 0 Sun ... 6 Sat
  const diffToMonday = (day + 6) % 7;
  const start = new Date(d);
  start.setDate(start.getDate() - diffToMonday);
  start.setHours(0, 0, 0, 0);
  const end = new Date(start);
  end.setDate(end.getDate() + 6);
  end.setHours(23, 59, 59, 999);
  return { start: start, end: end };
}

function parseDateKeyLocal_(dateKey) {
  if (!dateKey) return null;
  if (dateKey instanceof Date && !isNaN(dateKey.getTime())) {
    const d = new Date(dateKey);
    d.setHours(12, 0, 0, 0);
    return d;
  }
  const s = String(dateKey).trim();
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
  if (m) {
    // Use midday local time to avoid DST boundary issues.
    return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]), 12, 0, 0);
  }
  const d = new Date(s);
  if (isNaN(d.getTime())) return null;
  d.setHours(12, 0, 0, 0);
  return d;
}

function isDateKeyInRange_(dateKey, range) {
  if (!dateKey || !range) return false;
  const d = parseDateKeyLocal_(dateKey);
  if (!d) return false;
  return d >= range.start && d <= range.end;
}

function getGeminiApiKey_() {
  const key = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  if (!key) throw new Error('Missing GEMINI_API_KEY in Script Properties (Apps Script > Project Settings > Script Properties)');
  return key;
}

function getGeminiModel_() {
  return PropertiesService.getScriptProperties().getProperty('GEMINI_MODEL') || 'gemini-1.5-flash';
}

function callGeminiText_(prompt) {
  const key = getGeminiApiKey_();
  const model = getGeminiModel_();
  const url = 'https://generativelanguage.googleapis.com/v1beta/models/' + encodeURIComponent(model) + ':generateContent?key=' + encodeURIComponent(key);
  const payload = {
    contents: [{ role: 'user', parts: [{ text: prompt }] }],
    generationConfig: { temperature: 0.3, maxOutputTokens: 420 }
  };
  const resp = UrlFetchApp.fetch(url, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  });
  const code = resp.getResponseCode();
  const body = resp.getContentText();
  if (code >= 400) {
    throw new Error('Gemini API error ' + code + ': ' + body);
  }
  const json = JSON.parse(body || '{}');
  const text =
    (json.candidates &&
      json.candidates[0] &&
      json.candidates[0].content &&
      json.candidates[0].content.parts &&
      json.candidates[0].content.parts[0] &&
      json.candidates[0].content.parts[0].text) || '';
  return String(text || '').trim();
}

/**
 * Generates a weekly executive summary using Gemini, writes it back to the On the Radar sheet,
 * and returns it to the frontend.
 */
function updateOnTheRadarSummary() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    let sheet = ss.getSheetByName(CONFIG.RADAR_TAB_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CONFIG.RADAR_TAB_NAME);
      initializeOnTheRadarSheet(sheet);
    }

    const radar = getOnTheRadar();
    const week = getWeekRange_(new Date());
    const weekLabel = Utilities.formatDate(week.start, Session.getScriptTimeZone(), 'MMM dd') +
      ' - ' + Utilities.formatDate(week.end, Session.getScriptTimeZone(), 'MMM dd, yyyy');

    const meetings = (getMeetings() || []).filter(m => m && isDateKeyInRange_(m.date, week));
    const agendas = (getAgendaItems() || []).filter(a => a && isDateKeyInRange_(a.date, week));

    const radarLines = (radar.items || []).slice(0, 30).map(it => {
      const bits = [];
      if (it.date) bits.push(it.date);
      if (it.owner) bits.push('Owner: ' + it.owner);
      if (it.tags) bits.push('Tags: ' + it.tags);
      return '- ' + it.statement + (bits.length ? ' (' + bits.join(' | ') + ')' : '');
    }).join('\n');

    const meetingLines = meetings.slice(0, 40).map(m => {
      const parts = [];
      if (m.dateFormatted || m.date) parts.push(m.dateFormatted || m.date);
      if (m.time) parts.push(m.time);
      if (m.isHotTopic) parts.push('HOT TOPIC');
      return '- ' + String(m.title || '').trim() + (parts.length ? ' [' + parts.join(' ‚Ä¢ ') + ']' : '');
    }).join('\n');

    const agendaLines = agendas.slice(0, 40).map(a => {
      const topics = (a.topics || []).slice(0, 6).map(t => (t && t.title) ? t.title : '').filter(Boolean);
      return '- ' + String(a.meetingType || a.title || 'Agenda') + ' (' + (a.dateFormatted || a.date || '') + '): ' +
        (topics.length ? topics.join('; ') : 'No topics listed');
    }).join('\n');

    const prompt =
      'You are an executive chief-of-staff. Write a compact weekly executive summary for the week of ' + weekLabel + '.\n' +
      'Requirements:\n' +
      '- Keep it concise and skimmable.\n' +
      '- Output format:\n' +
      '  1) 2-3 sentence summary paragraph\n' +
      '  2) Bullets under: Key Themes, Decisions/Asks, Risks\n' +
      '- Use only the provided inputs.\n\n' +
      'On the Radar statements:\n' + (radarLines || '(none)') + '\n\n' +
      'Meetings this week:\n' + (meetingLines || '(none)') + '\n\n' +
      'Submitted agendas this week:\n' + (agendaLines || '(none)') + '\n';

    const summaryText = callGeminiText_(prompt);
    const lastUpdated = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'MMM dd, yyyy HH:mm');

    sheet.getRange(CONFIG.RADAR_SUMMARY_CELL).setValue(summaryText || '(Gemini returned empty output)').setWrap(true);
    sheet.getRange(CONFIG.RADAR_LAST_UPDATED_CELL).setValue(lastUpdated).setFontColor('#6b7280');

    return { success: true, summary: summaryText, lastUpdated: lastUpdated };
  } catch (error) {
    Logger.log('Error updating On the Radar summary: ' + error);
    return { success: false, error: error.toString() };
  }
}

/**
 * Simple test function to verify backend connection
 */
function testConnection() {
  return {
    status: 'success',
    message: 'Backend is working!',
    timestamp: new Date().toISOString(),
    sheetId: CONFIG.DELIVERABLES_SHEET_ID
  };
}

/**
 * Test if getAllDashboardData can be serialized
 */
function testSerializability() {
  try {
    const data = getAllDashboardData();
    const jsonString = JSON.stringify(data);
    
    return {
      success: true,
      dataSize: jsonString.length,
      itemCounts: {
        exec1: data.exec1Deliverables.length,
        exec2: data.exec2Deliverables.length,
        meetings: data.meetings.length,
        agendas: data.agendaItems.length,
        recurring: data.recurringMeetings.length,
        admin: data.adminLinks.length,
        kpi: data.kpiLinks.length,
        updates: data.executiveUpdates.length,
        documents: data.documentRepository.length,
        completed: data.completedItems.length
      }
    };
  } catch (e) {
    return {
      success: false,
      error: e.toString(),
      stack: e.stack
    };
  }
}

/**
 * Archive completed meetings to separate sheet
 */
function archiveCompletedMeetings() {
  const sheet = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).getSheetByName('Meetings');
  let archive = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).getSheetByName('Meeting Archive');
  
  if (!archive) {
    archive = SpreadsheetApp.openById(CONFIG.MEETINGS_SHEET_ID).insertSheet('Meeting Archive');
    archive.getRange(1, 1, 1, 16).setValues([sheet.getRange(1, 1, 1, 16).getValues()[0]]);
    archive.getRange(1, 1, 1, 16).setFontWeight('bold').setBackground('#1e293b').setFontColor('#ffffff');
  }
  
  const data = sheet.getDataRange().getValues();
  const toArchive = [];
  const toDelete = [];
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === true) { // COMPLETE checkbox
      toArchive.push(data[i]);
      toDelete.push(i + 1);
    }
  }
  
  if (toArchive.length > 0) {
    const lastRow = archive.getLastRow();
    archive.getRange(lastRow + 1, 1, toArchive.length, 16).setValues(toArchive);
    
    for (let i = toDelete.length - 1; i >= 0; i--) {
      sheet.deleteRow(toDelete[i]);
    }
    
    Logger.log('‚úÖ Archived ' + toArchive.length + ' completed meetings');
    try {
      SpreadsheetApp.getUi().alert('‚úÖ Archived ' + toArchive.length + ' completed meetings');
    } catch (e) {
      Logger.log('Alert not available in this context');
    }
  } else {
    Logger.log('No completed meetings to archive');
    try {
      SpreadsheetApp.getUi().alert('No completed meetings to archive');
    } catch (e) {
      Logger.log('Alert not available in this context');
    }
  }
}

/**
 * Get Exec 1 Deliverables (DYNAMIC - stops at first empty row)
 */
function getExec1Deliverables() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const bounds = getDeliverablesSectionBounds_('exec1');
    const startRow = bounds.startRow;
    const maxRows = bounds.endRow - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const deliverables = [];
    const today = new Date();
    
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      const etaCell = row[1];
      const etaStr = etaCell ? String(etaCell).trim() : '';
      const isWeeklyEta = etaStr && etaStr.toLowerCase().includes('weekly');
      const eta = !isWeeklyEta && etaCell ? new Date(etaCell) : null;
      const daysRemaining = isWeeklyEta ? null : (eta ? Math.ceil((eta - today) / (1000 * 60 * 60 * 24)) : null);
      
      // Extract URL from Column D hyperlink
      let linkedMaterials = '';
      const richText = richTextValues[i][3];
      if (richText) {
        linkedMaterials = richText.getLinkUrl() || '';
      }
      if (!linkedMaterials && row[3]) {
        linkedMaterials = String(row[3]);
      }
      
      deliverables.push({
        id: 'exec1-' + i,
        description: row[0] || '',
        eta: isWeeklyEta ? 'Weekly' : (eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'MMM dd') : ''),
        etaFull: isWeeklyEta ? '' : (eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'yyyy-MM-dd') : ''),
        owner: row[2] || '',
        linkedMaterials: linkedMaterials,
        daysRemaining: daysRemaining,
        daysRemainingText: isWeeklyEta ? 'N/A' : (daysRemaining !== null ? Math.abs(daysRemaining) + 'd' : ''),
        comment: row[6] || '',
        isHotTopic: !isWeeklyEta && daysRemaining !== null && daysRemaining <= 7,
        isOverdue: daysRemaining !== null && daysRemaining < 0,
        urgency: getUrgencyLevel(daysRemaining)
      });
    }
    
    return deliverables;
  } catch (error) {
    Logger.log('Error getting Exec 1 deliverables: ' + error);
    return [];
  }
}

/**
 * Get Exec 2 Deliverables (DYNAMIC)
 */
function getExec2Deliverables() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const bounds = getDeliverablesSectionBounds_('exec2');
    const startRow = bounds.startRow;
    const maxRows = bounds.endRow - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const deliverables = [];
    const today = new Date();
    
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      const etaCell = row[1];
      const etaStr = etaCell ? String(etaCell).trim() : '';
      const isWeeklyEta = etaStr && etaStr.toLowerCase().includes('weekly');
      const eta = !isWeeklyEta && etaCell ? new Date(etaCell) : null;
      const daysRemaining = isWeeklyEta ? null : (eta ? Math.ceil((eta - today) / (1000 * 60 * 60 * 24)) : null);
      
      // Extract URL from Column D hyperlink
      let linkedMaterials = '';
      const richText = richTextValues[i][3];
      if (richText) {
        linkedMaterials = richText.getLinkUrl() || '';
      }
      if (!linkedMaterials && row[3]) {
        linkedMaterials = String(row[3]);
      }
      
      deliverables.push({
        id: 'exec2-' + i,
        description: row[0] || '',
        eta: isWeeklyEta ? 'Weekly' : (eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'MMM dd') : ''),
        etaFull: isWeeklyEta ? '' : (eta ? Utilities.formatDate(eta, Session.getScriptTimeZone(), 'yyyy-MM-dd') : ''),
        owner: row[2] || '',
        linkedMaterials: linkedMaterials,
        daysRemaining: daysRemaining,
        daysRemainingText: isWeeklyEta ? 'N/A' : (daysRemaining !== null ? Math.abs(daysRemaining) + 'd' : ''),
        comment: row[6] || '',
        isHotTopic: !isWeeklyEta && daysRemaining !== null && daysRemaining <= 7,
        isOverdue: daysRemaining !== null && daysRemaining < 0,
        urgency: getUrgencyLevel(daysRemaining)
      });
    }
    
    return deliverables;
  } catch (error) {
    Logger.log('Error getting Exec 2 deliverables: ' + error);
    return [];
  }
}

/**
 * Get meetings for 2-week schedule view
 */
function normalizeMeetingTime(rawTime) {
  if (!rawTime) {
    return { time12: '', time24: '' };
  }
  
  if (rawTime instanceof Date) {
    return {
      time12: Utilities.formatDate(rawTime, Session.getScriptTimeZone(), 'h:mm a'),
      time24: Utilities.formatDate(rawTime, Session.getScriptTimeZone(), 'HH:mm')
    };
  }
  
  const str = String(rawTime).trim();
  const ampmMatch = str.match(/^(\d{1,2})(?::(\d{2}))?\s*(AM|PM)$/i);
  if (ampmMatch) {
    let hour = parseInt(ampmMatch[1], 10);
    const minute = (ampmMatch[2] || '00').padStart(2, '0');
    const ampm = ampmMatch[3].toUpperCase();
    if (ampm === 'PM' && hour !== 12) hour += 12;
    if (ampm === 'AM' && hour === 12) hour = 0;
    const time24 = String(hour).padStart(2, '0') + ':' + minute;
    const hour12 = hour % 12 || 12;
    const time12 = hour12 + ':' + minute + ' ' + ampm;
    return { time12: time12, time24: time24 };
  }
  
  const militaryMatch = str.match(/^(\d{1,2}):(\d{2})/);
  if (militaryMatch) {
    let hour = parseInt(militaryMatch[1], 10);
    const minute = militaryMatch[2];
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const hour12 = hour % 12 || 12;
    const time12 = hour12 + ':' + minute + ' ' + ampm;
    const time24 = String(hour).padStart(2, '0') + ':' + minute;
    return { time12: time12, time24: time24 };
  }
  
  return { time12: str, time24: '' };
}

/**
 * Extract URL from a RichTextValue or fallback cell value
 */
function getUrlFromRichText(richText, fallbackValue, fallbackFormula) {
  try {
    if (richText) {
      const direct = richText.getLinkUrl && richText.getLinkUrl();
      if (direct) return direct;
      
      if (richText.getRuns) {
        const runs = richText.getRuns();
        for (let i = 0; i < runs.length; i++) {
          const url = runs[i].getLinkUrl();
          if (url) return url;
        }
      }
    }
  } catch (e) {
    Logger.log('Warning: Rich text URL extraction failed: ' + e);
  }
  
  if (fallbackFormula) {
    const formulaMatch = String(fallbackFormula).match(/HYPERLINK\(\"([^\"]+)\"/i);
    if (formulaMatch && formulaMatch[1]) return formulaMatch[1];
  }
  
  if (fallbackValue && String(fallbackValue).match(/^https?:\/\//i)) {
    return String(fallbackValue).trim();
  }
  
  return '';
}

/**
 * Get meetings for 2-week schedule view
 */
function getMeetings() {
  try {
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (sheet.getLastRow() < 2) return [];
    
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    const richTextValues = dataRange.getRichTextValues();
    const formulas = dataRange.getFormulas();
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    // Show meetings from start of previous month to end of next year for full calendar support
    const rangeStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
    const rangeEnd = new Date(today.getFullYear() + 1, 11, 31);
    
    const meetings = [];
    
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      if (!row[CONFIG.MEETING_COLUMNS.MEETING_NAME]) continue;
      
      const meetingDate = new Date(row[CONFIG.MEETING_COLUMNS.DATE]);
      if (!(meetingDate instanceof Date) || isNaN(meetingDate.getTime())) continue;
      
      // Skip weekends (0 = Sunday, 6 = Saturday)
      const dayOfWeek = meetingDate.getDay();
      if (dayOfWeek === 0 || dayOfWeek === 6) continue;

      if (meetingDate >= rangeStart && meetingDate <= rangeEnd) {
        const normalizedTime = normalizeMeetingTime(row[CONFIG.MEETING_COLUMNS.TIME]);
        const colorMeta = row[CONFIG.MEETING_COLUMNS.COLOR_ID] ? String(row[CONFIG.MEETING_COLUMNS.COLOR_ID]).trim() : '';
        const keywordLevel = getHotTopicLevelFromText(row[CONFIG.MEETING_COLUMNS.MEETING_NAME], row[CONFIG.MEETING_COLUMNS.DESCRIPTION]);
        let hotTopicLevel = '';
        if (colorMeta === '11') hotTopicLevel = 'urgent';
        if (colorMeta === '6') hotTopicLevel = 'must-attend';
        if (!hotTopicLevel && (colorMeta === 'urgent' || colorMeta === 'must-attend')) hotTopicLevel = colorMeta;
        if (!hotTopicLevel && keywordLevel) hotTopicLevel = keywordLevel;
        
        const isHotTopic = row[CONFIG.MEETING_COLUMNS.HOT_TOPIC] === true || !!hotTopicLevel;
        
        const richLinkCell = richTextValues[i] ? richTextValues[i][CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] : null;
        const formulaCell = formulas[i] ? formulas[i][CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK] : '';
        const deliverableLink = getUrlFromRichText(
          richLinkCell,
          row[CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK],
          formulaCell
        );
        
        meetings.push({
          id: row[CONFIG.MEETING_COLUMNS.EVENT_ID] || 'meeting-' + i,
          title: row[CONFIG.MEETING_COLUMNS.MEETING_NAME] || '',
          date: Utilities.formatDate(meetingDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
          dateFormatted: Utilities.formatDate(meetingDate, Session.getScriptTimeZone(), 'MMM dd'),
          time: normalizedTime.time12,
          time24: normalizedTime.time24,
          duration: String(row[CONFIG.MEETING_COLUMNS.DURATION] || ''),
          frequency: String(row[CONFIG.MEETING_COLUMNS.FREQUENCY] || ''),
          category: row[CONFIG.MEETING_COLUMNS.CATEGORY] || 'meeting',
          description: row[CONFIG.MEETING_COLUMNS.DESCRIPTION] || '',
          attendees: row[CONFIG.MEETING_COLUMNS.ATTENDEES] || '',
          approved: row[CONFIG.MEETING_COLUMNS.APPROVED] === true,
          isHotTopic: isHotTopic,
          hotTopicLevel: hotTopicLevel,
          colorId: colorMeta,
          prepRequired: row[CONFIG.MEETING_COLUMNS.PREP_REQUIRED] === true,
          deliverableLink: deliverableLink || '',
          notes: row[CONFIG.MEETING_COLUMNS.NOTES] || '',
          dayOfWeek: meetingDate.getDay(),
          _rowIndex: i + 1
        });
      }
    }
    
    // Sort by date and time
    meetings.sort((a, b) => {
      const dateCompare = a.date.localeCompare(b.date);
      if (dateCompare !== 0) return dateCompare;
      
      // Compare times as strings (format: "HH:mm")
      const timeA = a.time24 || '00:00';
      const timeB = b.time24 || '00:00';
      return timeA.localeCompare(timeB);
    });
    
    return meetings;
  } catch (error) {
    Logger.log('Error getting meetings: ' + error);
    return [];
  }
}

/**
 * Get recurring meetings for agenda builder
 */
function getRecurringMeetings() {
  try {
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (sheet.getLastRow() < 2) return [];
    
    const dataRange = sheet.getDataRange();
    const values = dataRange.getValues();
    
    const recurringMeetings = [];
    const seen = new Set();
    
    for (let i = 1; i < values.length; i++) {
      const row = values[i];
      const frequency = row[CONFIG.MEETING_COLUMNS.FREQUENCY] ? row[CONFIG.MEETING_COLUMNS.FREQUENCY].toString().toLowerCase() : '';
      const meetingName = row[CONFIG.MEETING_COLUMNS.MEETING_NAME];
      
      if (meetingName && frequency && 
          (frequency.includes('weekly') || frequency.includes('monthly') || 
           frequency.includes('daily') || frequency.includes('bi-weekly'))) {
        
        const key = meetingName.toString().trim();
        if (!seen.has(key)) {
          seen.add(key);
          recurringMeetings.push({
            id: row[CONFIG.MEETING_COLUMNS.EVENT_ID] || 'recurring-' + i,
            name: meetingName,
            frequency: row[CONFIG.MEETING_COLUMNS.FREQUENCY]
          });
        }
      }
    }
    
    return recurringMeetings;
  } catch (error) {
    Logger.log('Error getting recurring meetings: ' + error);
    return [];
  }
}

/**
 * Extract agenda topics from a notes field
 */
function extractAgendaTopicsFromNotes(notes) {
  if (!notes) return [];
  
  const marker = 'Agenda Topics:';
  const text = String(notes);
  const index = text.indexOf(marker);
  if (index === -1) return [];
  
  const raw = text.slice(index + marker.length).trim();
  if (!raw) return [];
  
  const lines = raw.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
  const topics = [];
  
  lines.forEach(line => {
    let cleaned = line.replace(/^[-‚Ä¢\d\.\)\s]+/, '').trim();
    if (!cleaned) return;
    if (cleaned.toLowerCase().startsWith('notes:')) return;
    topics.push(cleaned);
  });
  
  return topics;
}

/**
 * Normalize agenda dates
 */
function normalizeAgendaDate(rawDate) {
  if (!rawDate) return null;
  let dateObj = null;
  if (rawDate instanceof Date) {
    dateObj = new Date(rawDate);
  } else {
    const parsed = new Date(rawDate);
    if (parsed instanceof Date && !isNaN(parsed.getTime())) {
      dateObj = parsed;
    }
  }
  if (!dateObj) return null;
  dateObj.setHours(0, 0, 0, 0);
  return {
    dateObj: dateObj,
    dateKey: Utilities.formatDate(dateObj, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
    dateFormatted: Utilities.formatDate(dateObj, Session.getScriptTimeZone(), 'MMM dd')
  };
}

/**
 * Normalize agenda durations
 */
function normalizeAgendaDuration(rawDuration) {
  if (rawDuration === null || typeof rawDuration === 'undefined' || rawDuration === '') return '';
  if (rawDuration instanceof Date) {
    return Utilities.formatDate(rawDuration, Session.getScriptTimeZone(), 'H:mm');
  }
  return String(rawDuration).trim();
}

/**
 * Get agenda items from agenda tabs
 */
function getAgendaItemsFromAgendaTabs() {
  try {
    const agendaItems = [];
    let foundTab = false;
    const tabNames = getAgendaTabNames_();
    if (!tabNames.length) return { items: [], foundTab: false };
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    tabNames.forEach(tabName => {
      const sheet = getSheet(CONFIG.AGENDA_SHEET_ID, tabName);
      if (!sheet) {
        Logger.log('Agenda tab not found: ' + tabName);
        return;
      }
      foundTab = true;
      
      if (sheet.getLastRow() < 2) return;
      
      const range = sheet.getDataRange();
      const values = range.getValues();
      const richTextValues = range.getRichTextValues();
      const formulas = range.getFormulas();
      
      for (let i = 1; i < values.length; i++) {
        const row = values[i];
        const dateInfo = normalizeAgendaDate(row[CONFIG.AGENDA_COLUMNS.DATE]);
        if (!dateInfo) continue;
        if (dateInfo.dateObj < today) continue;
        
        const topics = [];
        for (let t = 0; t < CONFIG.AGENDA_COLUMNS.TOPIC_COUNT; t++) {
          const topicCol = CONFIG.AGENDA_COLUMNS.TOPIC_START + (t * CONFIG.AGENDA_COLUMNS.TOPIC_STRIDE);
          const durationCol = topicCol + 1;
          const topicValue = row[topicCol];
          if (!topicValue || String(topicValue).trim() === '') continue;
          const durationValue = row[durationCol];
          topics.push({
            title: String(topicValue).trim(),
            duration: normalizeAgendaDuration(durationValue)
          });
        }
        
        const linkCell = row[CONFIG.AGENDA_COLUMNS.LINK];
        const richLinkCell = richTextValues[i] ? richTextValues[i][CONFIG.AGENDA_COLUMNS.LINK] : null;
        const formulaCell = formulas[i] ? formulas[i][CONFIG.AGENDA_COLUMNS.LINK] : '';
        const agendaLink = getUrlFromRichText(richLinkCell, linkCell, formulaCell);
        
        if (topics.length === 0 && !agendaLink) continue;
        
        agendaItems.push({
          id: 'agenda-' + tabName.toString().replace(/\s+/g, '-').toLowerCase() + '-' + i,
          title: tabName,
          meetingType: tabName,
          date: dateInfo.dateKey,
          dateFormatted: dateInfo.dateFormatted,
          agendaLink: agendaLink,
          linkLabel: 'Open Deck',
          topics: topics
        });
      }
    });
    
    // Sort by date/time
    agendaItems.sort((a, b) => {
      const dateCompare = String(a.date).localeCompare(String(b.date));
      if (dateCompare !== 0) return dateCompare;
      return String(a.meetingType || '').localeCompare(String(b.meetingType || ''));
    });
    
    return { items: agendaItems, foundTab: foundTab };
  } catch (error) {
    Logger.log('Error getting agenda items from tabs: ' + error);
    return { items: [], foundTab: false };
  }
}

/**
 * Get agenda items for upcoming meetings (legacy fallback)
 */
function getAgendaItemsFromMeetings() {
  try {
    const meetings = getMeetings();
    if (!meetings || meetings.length === 0) return [];
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const agendaItems = [];
    
    meetings.forEach(meeting => {
      if (!meeting || !meeting.date) return;
      const meetingDate = new Date(meeting.date + 'T00:00:00');
      if (!(meetingDate instanceof Date) || isNaN(meetingDate.getTime())) return;
      if (meetingDate < today) return;
      
      const topics = extractAgendaTopicsFromNotes(meeting.notes || '');
      const agendaLink = meeting.deliverableLink || '';
      
      if (topics.length === 0 && !agendaLink) return;
      
      agendaItems.push({
        id: meeting.id,
        title: meeting.title,
        date: meeting.date,
        dateFormatted: meeting.dateFormatted,
        time: meeting.time,
        time24: meeting.time24,
        agendaLink: agendaLink,
        topics: topics
      });
    });
    
    // Sort by date/time
    agendaItems.sort((a, b) => {
      const dateCompare = String(a.date).localeCompare(String(b.date));
      if (dateCompare !== 0) return dateCompare;
      return String(a.time24 || '').localeCompare(String(b.time24 || ''));
    });
    
    return agendaItems;
  } catch (error) {
    Logger.log('Error getting agenda items from meetings: ' + error);
    return [];
  }
}

/**
 * Get agenda items for upcoming meetings
 */
function getAgendaItems() {
  const tabResult = getAgendaItemsFromAgendaTabs();
  if (tabResult && tabResult.foundTab) return tabResult.items;
  return getAgendaItemsFromMeetings();
}

/**
 * Add agenda entry to agenda tabs from dashboard UI
 */
function addAgendaEntry(data) {
  try {
    const meetingType = data && data.meetingType ? String(data.meetingType).trim() : '';
    const dateValue = data && data.date ? String(data.date).trim() : '';
    const topics = data && data.topics ? data.topics : [];
    const agendaLink = data && data.agendaLink ? String(data.agendaLink).trim() : '';
    
    if (!meetingType) return { success: false, error: 'Missing agenda type' };
    if (!dateValue) return { success: false, error: 'Missing meeting date' };
    
    const ss = SpreadsheetApp.openById(CONFIG.AGENDA_SHEET_ID);
    let sheet = ss.getSheetByName(meetingType);
    if (!sheet) {
      // Allow the frontend to add new agenda types; create the tab automatically.
      sheet = ss.insertSheet(meetingType);
      initializeAgendaTab_(sheet);
      try {
        const props = PropertiesService.getScriptProperties();
        const next = uniqStrings_([].concat(getAgendaTabNames_(), [meetingType]));
        props.setProperty('AGENDA_TAB_NAMES', JSON.stringify(next));
      } catch (e) {}
    }
    
    const row = new Array(CONFIG.AGENDA_COLUMNS.LINK + 1).fill('');
    const dateObj = new Date(dateValue + 'T00:00:00');
    row[CONFIG.AGENDA_COLUMNS.DATE] = isNaN(dateObj.getTime()) ? dateValue : dateObj;
    
    for (let i = 0; i < CONFIG.AGENDA_COLUMNS.TOPIC_COUNT; i++) {
      const topic = topics[i];
      if (!topic || !topic.title) continue;
      const topicCol = CONFIG.AGENDA_COLUMNS.TOPIC_START + (i * CONFIG.AGENDA_COLUMNS.TOPIC_STRIDE);
      row[topicCol] = String(topic.title).trim();
      row[topicCol + 1] = topic.duration ? String(topic.duration).trim() : '';
    }
    
    if (agendaLink) {
      row[CONFIG.AGENDA_COLUMNS.LINK] = agendaLink;
    }
    
    sheet.appendRow(row);
    
    return { success: true };
  } catch (error) {
    Logger.log('Error adding agenda entry: ' + error);
    return { success: false, error: error.toString() };
  }
}

/**
 * Get Admin Links (DYNAMIC)
 */
function getAdminLinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.ADMIN_START_ROW;
    const maxRows = CONFIG.ADMIN_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'admin-' + i,
        name: String(row[0] || ''),
        url: url,
        category: 'admin'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting admin links: ' + error);
    return [];
  }
}

/**
 * Get KPI Links (DYNAMIC)
 */
function getKPILinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.KPI_START_ROW;
    const maxRows = CONFIG.KPI_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'kpi-' + i,
        name: String(row[0] || ''),
        url: url,
        category: 'kpi'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting KPI links: ' + error);
    return [];
  }
}

/**
 * Get Executive Updates (DYNAMIC)
 */
function getExecutiveUpdates() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.EXEC_UPDATES_START_ROW;
    const maxRows = CONFIG.EXEC_UPDATES_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const updates = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      updates.push({
        id: 'update-' + i,
        name: String(row[0] || ''),
        url: url,
        dateAdded: row[1] ? Utilities.formatDate(new Date(row[1]), Session.getScriptTimeZone(), 'MMM dd, yyyy') : '',
        category: 'executive-update'
      });
    }
    
    return updates;
  } catch (error) {
    Logger.log('Error getting executive updates: ' + error);
    return [];
  }
}

/**
 * Get Document Repository items (DYNAMIC) - NEW SECTION!
 */
function getDocumentRepository() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.DOCUMENTS_START_ROW;
    const maxRows = CONFIG.DOCUMENTS_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    
    const documents = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Safely handle date formatting
      let dateAdded = '';
      try {
        if (row[1] && row[1] instanceof Date) {
          dateAdded = Utilities.formatDate(row[1], Session.getScriptTimeZone(), 'MMM dd, yyyy');
        } else if (row[1]) {
          dateAdded = row[1].toString();
        }
      } catch (e) {
        Logger.log('Warning: Invalid date in Document Repository row ' + (startRow + i));
      }
      
      documents.push({
        id: 'document-' + i,
        name: String(row[0] || ''),
        url: String(row[3] || ''),
        dateAdded: dateAdded,
        owner: String(row[2] || ''),
        category: 'document'
      });
    }
    
    return documents;
  } catch (error) {
    Logger.log('Error getting document repository: ' + error);
    return [];
  }
}

/**
 * Get Completed Items (function getCompletedItems() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.COMPLETED_START_ROW;
    const maxRows = CONFIG.COMPLETED_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    
    const completed = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      completed.push({
        id: 'completed-' + i,
        description: row[0],
        eta: row[1] instanceof Date ? Utilities.formatDate(row[1], Session.getScriptTimeZone(), 'MMM dd') : row[1],
        owner: row[2],
        link: row[3],
        daysLeft: row[4],
        comment: row[6]
      });
    }
    return completed;
  } catch (error) {
    Logger.log('Error getting completed items: ' + error);
    return [];
  }
}

/**
 * Get active alerts for the scrolling banner
 */
function getAlerts() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.ALERT_SHEET_NAME);
    if (!sheet) return [];
    
    const data = sheet.getDataRange().getValues();
    const alerts = [];
    
    // Column A: Active (Checkbox), Column B: Alert Text
    for (let i = CONFIG.ALERT_START_ROW - 1; i < data.length; i++) {
      if (data[i][0] === true && data[i][1]) {
        alerts.push(data[i][1]);
      }
    }
    return alerts;
  } catch (error) {
    Logger.log('Error getting alerts: ' + error);
    return [];
  }
}
// ===========================================
// AGENDA CREATION FUNCTIONS
// ============================================================================

/**
 * Create agenda document
 */
function createAgenda(meetingData) {
  try {
    const { meetingName, meetingDate, topics, meetingLink } = meetingData;
    
    const doc = DocumentApp.create(`${meetingName} - Agenda - ${meetingDate}`);
    const body = doc.getBody();
    
    // Title
    const title = body.appendParagraph(meetingName);
    title.setHeading(DocumentApp.ParagraphHeading.HEADING1);
    title.setAlignment(DocumentApp.HorizontalAlignment.CENTER);
    
    // Date
    const dateP = body.appendParagraph(meetingDate);
    dateP.setAlignment(DocumentApp.HorizontalAlignment.CENTER);
    body.appendParagraph('');
    
    // Meeting link
    if (meetingLink) {
      const linkP = body.appendParagraph('Meeting Link: ');
      linkP.appendText(meetingLink).setLinkUrl(meetingLink);
      body.appendParagraph('');
    }
    
    // Agenda topics
    const topicsHeading = body.appendParagraph('Agenda Topics');
    topicsHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    
    topics.forEach((topic, index) => {
      if (topic && topic.trim() !== '') {
        const topicP = body.appendParagraph(`${index + 1}. ${topic}`);
        topicP.setIndentFirstLine(36);
        body.appendParagraph('   Notes:');
        body.appendParagraph('');
      }
    });
    
    // Action items
    body.appendParagraph('');
    const actionHeading = body.appendParagraph('Action Items');
    actionHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    body.appendParagraph('‚Ä¢ ');
    body.appendParagraph('‚Ä¢ ');
    body.appendParagraph('‚Ä¢ ');
    
    // Next steps
    body.appendParagraph('');
    const nextStepsHeading = body.appendParagraph('Next Steps');
    nextStepsHeading.setHeading(DocumentApp.ParagraphHeading.HEADING2);
    body.appendParagraph('');
    
    doc.saveAndClose();
    
    return {
      success: true,
      documentUrl: doc.getUrl(),
      documentId: doc.getId(),
      documentName: doc.getName()
    };
    
  } catch (error) {
    Logger.log('Error creating agenda: ' + error);
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Attach agenda document link to a meeting row
 */
function attachAgendaToMeeting(data) {
  try {
    const { meetingId, documentUrl, documentName, agendaSummary } = data;
    if (!meetingId || !documentUrl) {
      return { success: false, error: 'Missing meetingId or documentUrl' };
    }
    
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (!sheet) {
      return { success: false, error: 'Meetings sheet not found' };
    }
    
    const values = sheet.getDataRange().getValues();
    let targetRow = -1;
    for (let i = 1; i < values.length; i++) {
      if (String(values[i][CONFIG.MEETING_COLUMNS.EVENT_ID] || '') === String(meetingId)) {
        targetRow = i + 1;
        break;
      }
    }
    
    if (targetRow === -1) {
      return { success: false, error: 'Meeting not found' };
    }
    
    const linkCell = sheet.getRange(targetRow, CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK + 1);
    linkCell.setFormula('=HYPERLINK(\"' + documentUrl + '\", \"' + (documentName || 'Agenda') + '\")');

    if (agendaSummary && String(agendaSummary).trim()) {
      const notesCell = sheet.getRange(targetRow, CONFIG.MEETING_COLUMNS.NOTES + 1);
      const existing = notesCell.getValue() ? String(notesCell.getValue()).trim() : '';
      const agendaBlock = 'Agenda Topics:\n' + agendaSummary;
      const merged = existing ? (existing + '\n\n' + agendaBlock) : agendaBlock;
      notesCell.setValue(merged);
    }
    
    return { success: true };
  } catch (error) {
    Logger.log('Error attaching agenda: ' + error);
    return { success: false, error: error.toString() };
  }
}

/**
 * Update meeting fields from the dashboard modal
 */
function updateMeeting(meetingId, updates) {
  try {
    // Backward-compatible calling conventions:
    // - updateMeeting(meetingId, updates)
    // - updateMeeting({ id, ...updates })
    if (meetingId && typeof meetingId === 'object' && !updates) {
      updates = meetingId;
      meetingId = updates && (updates.id || updates.meetingId);
    }
    if (!meetingId) return { success: false, error: 'Missing meetingId' };
    if (!updates || typeof updates !== 'object') updates = {};
    
    const sheet = getSheet(CONFIG.MEETINGS_SHEET_ID, CONFIG.MEETINGS_TAB_NAME);
    if (!sheet) return { success: false, error: 'Meetings sheet not found' };
    
    const values = sheet.getDataRange().getValues();
    let targetRow = -1;
    
    // Allow editing rows without an EVENT_ID by using the synthetic id "meeting-<i>"
    // where <i> matches the dataRange row index used in getMeetings().
    const m = /^meeting-(\d+)$/.exec(String(meetingId));
    if (m) {
      const idx = parseInt(m[1], 10);
      if (!isNaN(idx) && idx >= 1 && idx < values.length) {
        targetRow = idx + 1; // +1 because sheet rows are 1-based and include header row.
      }
    }
    
    if (targetRow === -1) {
      for (let i = 1; i < values.length; i++) {
        if (String(values[i][CONFIG.MEETING_COLUMNS.EVENT_ID] || '') === String(meetingId)) {
          targetRow = i + 1;
          break;
        }
      }
    }
    
    if (targetRow === -1) return { success: false, error: 'Meeting not found' };

    const marker = 'Agenda Topics:';
    const notesCell = sheet.getRange(targetRow, CONFIG.MEETING_COLUMNS.NOTES + 1);
    const existingNotesRaw = notesCell.getValue() ? String(notesCell.getValue()) : '';
    const existingBase = existingNotesRaw.split(marker)[0].trim();
    const existingAgenda = existingNotesRaw.includes(marker) ? existingNotesRaw.split(marker)[1].trim() : '';

    // Notes: if not provided, keep existing base notes.
    const incomingNotesRaw = Object.prototype.hasOwnProperty.call(updates, 'notes') ? String(updates.notes || '') : null;
    const incomingBase = incomingNotesRaw === null ? existingBase : incomingNotesRaw.split(marker)[0].trim();

    // Agenda topics: prefer explicit field; else, if notes includes marker, extract; else keep existing.
    let agendaTopics = null;
    if (Object.prototype.hasOwnProperty.call(updates, 'agendaTopics')) {
      agendaTopics = String(updates.agendaTopics || '').trim();
    } else if (incomingNotesRaw !== null && incomingNotesRaw.includes(marker)) {
      agendaTopics = incomingNotesRaw.split(marker)[1].trim();
    } else {
      agendaTopics = existingAgenda;
    }

    // Only write notes if caller is changing notes/agendaTopics.
    if (incomingNotesRaw !== null || Object.prototype.hasOwnProperty.call(updates, 'agendaTopics')) {
      const agendaBlock = agendaTopics ? (marker + '\n' + agendaTopics) : '';
      const finalNotes = incomingBase && agendaBlock ? (incomingBase + '\n\n' + agendaBlock) : (incomingBase || agendaBlock);
      notesCell.setValue(finalNotes);
    }

    // Deliverable link: only mutate if explicitly provided.
    if (Object.prototype.hasOwnProperty.call(updates, 'deliverableLink')) {
      const linkCell = sheet.getRange(targetRow, CONFIG.MEETING_COLUMNS.DELIVERABLE_LINK + 1);
      if (updates.deliverableLink && String(updates.deliverableLink).trim()) {
        linkCell.setFormula('=HYPERLINK(\"' + updates.deliverableLink + '\", \"Agenda\")');
      } else {
        linkCell.setValue('');
      }
    }
    
    return { success: true };
  } catch (error) {
    Logger.log('Error updating meeting: ' + error);
    return { success: false, error: error.toString() };
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get sheet by ID and tab name
 */
function getSheet(sheetId, tabName) {
  const ss = SpreadsheetApp.openById(sheetId);
  return ss.getSheetByName(tabName);
}

/**
 * Calculate urgency level
 */
function getUrgencyLevel(daysRemaining) {
  if (daysRemaining === null) return 'none';
  if (daysRemaining < 0) return 'overdue';
  if (daysRemaining <= 5) return 'critical';
  if (daysRemaining <= 10) return 'high';
  if (daysRemaining <= 20) return 'medium';
  return 'low';
}

/**
 * Test function
 */
function testDataRetrieval() {
  Logger.log('Testing data retrieval...');
  Logger.log('Exec 1 Deliverables:', JSON.stringify(getExec1Deliverables(), null, 2));
  Logger.log('Meetings:', JSON.stringify(getMeetings(), null, 2));
  Logger.log('Recurring Meetings:', JSON.stringify(getRecurringMeetings(), null, 2));
}

// ============================================================================
// V8 NEW FUNCTIONS
// ============================================================================

/**
 * Get Document Repository Links (separate from main document list)
 */
function getDocumentRepoLinks() {
  try {
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    const startRow = CONFIG.DOCUMENTS_START_ROW;
    const maxRows = CONFIG.DOCUMENTS_END_ROW - startRow + 1;
    
    const range = sheet.getRange(startRow, 1, maxRows, 7);
    const values = range.getValues();
    const richTextValues = range.getRichTextValues();
    
    const links = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (!row[0] || row[0].toString().trim() === '') break;
      
      // Extract URL from Column D hyperlink
      let url = '';
      const richText = richTextValues[i][3];
      if (richText) {
        url = richText.getLinkUrl() || '';
      }
      if (!url && row[3]) {
        url = String(row[3]);
      }
      
      links.push({
        id: 'doc-repo-' + i,
        name: String(row[0] || ''),
        description: String(row[0] || ''),
        url: url,  // Column D
        link: url,  // Column D
        owner: String(row[2] || ''),
        comment: String(row[4] || ''),
        category: 'document-repo'
      });
    }
    
    return links;
  } catch (error) {
    Logger.log('Error getting document repo links: ' + error);
    return [];
  }
}

/**
 * Complete an item and move it to destination
 */
function completeItem(itemId, destination) {
  try {
    Logger.log('Completing item: ' + itemId + ' to ' + destination);
    
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.DELIVERABLES_TAB_NAME };
    }
    
    // Parse item ID to extract section and index (e.g., "exec1-5" or "document-3")
    const idParts = itemId.split('-');
    const itemType = idParts[0];
    const itemIndex = parseInt(idParts[1]);
    
    // Determine source section based on item type
    let startRow, endRow;
    if (itemType === 'exec1') {
      startRow = CONFIG.EXEC1_START_ROW;
      endRow = CONFIG.EXEC1_END_ROW;
    } else if (itemType === 'exec2') {
      startRow = CONFIG.EXEC2_START_ROW;
      endRow = CONFIG.EXEC2_END_ROW;
    } else if (itemType === 'document') {
      startRow = CONFIG.DOCUMENTS_START_ROW;
      endRow = CONFIG.DOCUMENTS_END_ROW;
    } else {
      return { success: false, error: 'Unknown item type: ' + itemType };
    }
    
    // Calculate actual row number
    const sourceRow = startRow + itemIndex;
    
    if (sourceRow > endRow) {
      return { success: false, error: 'Item index out of range' };
    }
    
    // Get the item data (7 columns standard)
    const sourceRange = sheet.getRange(sourceRow, 1, 1, 7);
    const itemData = sourceRange.getValues()[0];
    
    // Determine destination section (typically "completed" section)
    let destinationStartRow;
    if (destination === 'completed') {
      destinationStartRow = CONFIG.COMPLETED_START_ROW;
    } else {
      return { success: false, error: 'Unknown destination: ' + destination };
    }
    
    // Find first empty row in destination
    let destinationRow = destinationStartRow;
    const range = sheet.getRange(destinationStartRow, 1, CONFIG.COMPLETED_END_ROW - destinationStartRow + 1, 1);
    const values = range.getValues();
    
    for (let i = 0; i < values.length; i++) {
      if (!values[i][0] || values[i][0].toString().trim() === '') {
        destinationRow = destinationStartRow + i;
        break;
      }
    }
    
    // Move item to destination
    sheet.getRange(destinationRow, 1, 1, 7).setValues([itemData]);
    
    // Clear source row
    sourceRange.clearContent();
    
    Logger.log('‚úÖ Item ' + itemId + ' moved to ' + destination + ' at row ' + destinationRow);
    return { 
      success: true, 
      message: 'Item completed and moved to ' + destination,
      destinationRow: destinationRow
    };
    
  } catch (error) {
    Logger.log('Error completing item: ' + error);
    return { success: false, error: error.toString() };
  }
}

/**
 * Add new item to deliverables
 */
function addNewItem(itemData) {
  try {
    Logger.log('Adding new item to: ' + itemData.section);
    
    const sheet = getSheet(CONFIG.DELIVERABLES_SHEET_ID, CONFIG.DELIVERABLES_TAB_NAME);
    
    // Determine target section
    const sectionKey = String(itemData.section || '').trim();
    if (sectionKey !== 'exec1' && sectionKey !== 'exec2') {
      return { success: false, error: 'Unknown section: ' + sectionKey };
    }
    const bounds = getDeliverablesSectionBounds_(sectionKey);
    const targetStartRow = bounds.startRow;
    const targetEndRow = bounds.endRow;

    // Find first empty row in section (treat whitespace as empty)
    const colA = sheet.getRange(targetStartRow, 1, targetEndRow - targetStartRow + 1, 1).getDisplayValues();
    let targetRow = null;
    for (let i = 0; i < colA.length; i++) {
      const v = colA[i][0] ? String(colA[i][0]).trim() : '';
      if (!v) {
        targetRow = targetStartRow + i;
        break;
      }
    }
    if (!targetRow) {
      return { success: false, error: 'No empty rows available in section: ' + sectionKey };
    }
    
    // Prepare row data (adjust columns based on your sheet structure)
    const rowData = [
      itemData.description,
      itemData.eta || '',
      itemData.owner || '',
      itemData.link || ''
    ];
    
    // Insert data into columns A-D
    sheet.getRange(targetRow, 1, 1, rowData.length).setValues([rowData]);
    // Set hyperlink in Column D if provided
    if (itemData.link && String(itemData.link).trim()) {
      sheet.getRange(targetRow, 4).setFormula('=HYPERLINK(\"' + String(itemData.link).trim() + '\", \"Link to File\")');
    }
    // Comments go in column G
    sheet.getRange(targetRow, 7).setValue(itemData.comments || '');
    
    return { success: true, message: 'Item added successfully', row: targetRow };
    
  } catch (error) {
    Logger.log('Error adding item: ' + error);
    return { success: false, error: error.toString() };
  }
}
// ============================================================================
// DELIVERABLE CRUD FUNCTIONS
// ============================================================================

/**
 * Update a deliverable item
 * @param {Object} data - Deliverable data including execType, itemIndex, and all fields
 * @return {Object} Success/error response
 */
function updateDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.DELIVERABLES_TAB_NAME };
    }
    
    let execType = data.execType;
    let itemIndex = data.itemIndex;
    
    if ((!execType || itemIndex === undefined) && data.id) {
      const parts = String(data.id).split('-');
      if (parts.length === 2) {
        execType = parts[0];
        itemIndex = parseInt(parts[1], 10);
      }
    }
    
    if (execType !== 'exec1' && execType !== 'exec2') {
      return { success: false, error: 'Invalid execType: ' + execType };
    }
    
    if (isNaN(itemIndex)) {
      return { success: false, error: 'Invalid item index' };
    }
    
    const bounds = getDeliverablesSectionBounds_(execType);
    const startRow = bounds.startRow;
    const endRow = bounds.endRow;
    const actualRow = startRow + itemIndex;
    
    if (actualRow > endRow) {
      return { success: false, error: 'Item index out of range' };
    }
    
    // Update columns A-D and G (comment). Preserve calculated columns.
    sheet.getRange(actualRow, 1, 1, 4).setValues([[
      data.description || '',
      data.eta || '',
      data.owner || '',
      data.link || ''
    ]]);
    sheet.getRange(actualRow, 7).setValue(data.comments || '');
    
    if (data.link) {
      const linkCell = sheet.getRange(actualRow, 4);
      linkCell.setFormula('=HYPERLINK("' + data.link + '", "Link to File")');
    }
    
    Logger.log('‚úÖ Updated deliverable: ' + data.description);
    return { success: true, message: 'Deliverable updated successfully' };
    
  } catch (error) {
    Logger.log('‚ùå Error updating deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Delete a deliverable item
 * @param {Object} data - Contains execType and itemIndex
 * @return {Object} Success/error response
 */
function deleteDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.DELIVERABLES_TAB_NAME };
    }
    
    const execType = String(data.execType || '').trim();
    if (execType !== 'exec1' && execType !== 'exec2') {
      return { success: false, error: 'Invalid execType: ' + execType };
    }
    const bounds = getDeliverablesSectionBounds_(execType);
    const startRow = bounds.startRow;
    const endRow = bounds.endRow;
    
    // Calculate actual row number
    const actualRow = startRow + Number(data.itemIndex || 0);
    
    if (actualRow > endRow) {
      return { success: false, error: 'Item index out of range' };
    }
    
    // Clear the row (don't delete to preserve row numbers)
    const range = sheet.getRange(actualRow, 1, 1, 7);
    range.clearContent();
    
    Logger.log('‚úÖ Deleted deliverable at row: ' + actualRow);
    return { success: true, message: 'Deliverable deleted successfully' };
    
  } catch (error) {
    Logger.log('‚ùå Error deleting deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Add a new deliverable item
 * @param {Object} data - Deliverable data including execType and all fields
 * @return {Object} Success/error response
 */
function addDeliverable(data) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.DELIVERABLES_SHEET_ID);
    const sheet = ss.getSheetByName(CONFIG.DELIVERABLES_TAB_NAME);
    
    if (!sheet) {
      return { success: false, error: 'Sheet not found: ' + CONFIG.DELIVERABLES_TAB_NAME };
    }
    
    // Determine the row range based on execType (dynamic section bounds)
    const execType = String(data.execType || '').trim();
    if (execType !== 'exec1' && execType !== 'exec2') {
      return { success: false, error: 'Invalid execType: ' + execType };
    }
    const bounds = getDeliverablesSectionBounds_(execType);
    const startRow = bounds.startRow;
    const endRow = bounds.endRow;
    
    // Find the first empty row in the range (treat whitespace as empty)
    const values = sheet.getRange(startRow, 1, endRow - startRow + 1, 1).getDisplayValues();
    let emptyRow = null;
    for (let i = 0; i < values.length; i++) {
      const v = values[i][0] ? String(values[i][0]).trim() : '';
      if (!v) { emptyRow = startRow + i; break; }
    }
    
    if (!emptyRow) {
      return { success: false, error: 'No empty rows available in ' + execType + ' section' };
    }
    
    // Add the new item
    const newRange = sheet.getRange(emptyRow, 1, 1, 4);
    const newValues = [[
      data.description || '',
      data.eta || '',
      data.owner || '',
      data.link || ''
    ]];
    
    newRange.setValues(newValues);
    sheet.getRange(emptyRow, 7).setValue(data.comments || '');
    
    // Set hyperlink in Column D if provided
    if (data.link) {
      const linkCell = sheet.getRange(emptyRow, 4);
      linkCell.setFormula('=HYPERLINK("' + data.link + '", "Link to File")');
    }
    
    Logger.log('‚úÖ Added new deliverable: ' + data.description + ' at row ' + emptyRow);
    return { success: true, message: 'Deliverable added successfully', row: emptyRow };
    
  } catch (error) {
    Logger.log('‚ùå Error adding deliverable: ' + error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Generate PDF of 2-week schedule
 * @param {Object} options - Export options including selected meetings, week title, etc.
 * @return {Object} - Contains success status and download URL or error
 */
function generateWeeklySchedulePDF(options) {
  try {
    const { selectedMeetingIds, weekTitle, includePrepMeetings, agendaItems, notes } = options;
    
    // Get all meetings
    const allMeetings = getMeetings();
    
    // Filter to selected meetings only
    let meetings = allMeetings;
    if (selectedMeetingIds && selectedMeetingIds.length > 0) {
      meetings = allMeetings.filter(m => selectedMeetingIds.includes(m.id));
    }
    
    // Create a new Google Doc for the PDF
    const doc = DocumentApp.create('Two-Week Schedule - ' + (weekTitle || new Date().toLocaleDateString()));
    const body = doc.getBody();
    
    // Set page to landscape
    body.setPageWidth(792).setPageHeight(612); // Letter landscape
    body.setMarginTop(36);
    body.setMarginBottom(36);
    body.setMarginLeft(36);
    body.setMarginRight(36);
    
    // Compute current two-week range (Mon-Fri + next week)
    const scheduleToday = new Date();
    scheduleToday.setHours(0, 0, 0, 0);
    const scheduleDay = scheduleToday.getDay();
    const scheduleMondayOffset = scheduleDay === 0 ? -6 : 1 - scheduleDay;
    const monday = new Date(scheduleToday);
    monday.setDate(scheduleToday.getDate() + scheduleMondayOffset);
    const secondWeekMonday = new Date(monday);
    secondWeekMonday.setDate(monday.getDate() + 7);
    const rangeEnd = new Date(secondWeekMonday);
    rangeEnd.setDate(secondWeekMonday.getDate() + 4);
    const rangeLabel = Utilities.formatDate(monday, Session.getScriptTimeZone(), 'MMMM d') +
      '-' + Utilities.formatDate(rangeEnd, Session.getScriptTimeZone(), 'd, yyyy');
    const generatedLabel = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'MMM d, yyyy');

    // Header row (title left, generated right)
    const headerTable = body.appendTable([['', '']]);
    headerTable.setBorderWidth(0);
    const headerRow = headerTable.getRow(0);
    const titleCell = headerRow.getCell(0);
    const generatedCell = headerRow.getCell(1);
    titleCell.setWidth(420);
    generatedCell.setWidth(200);
    
    const titlePara = titleCell.appendParagraph('Executive Calendar Report');
    titlePara.setFontSize(16);
    titlePara.setBold(true);
    titlePara.setForegroundColor('#cc0000');
    
    const dateRangePara = titleCell.appendParagraph(rangeLabel);
    dateRangePara.setFontSize(9);
    dateRangePara.setForegroundColor('#555555');
    
    const generatedPara = generatedCell.appendParagraph('Generated: ' + generatedLabel);
    generatedPara.setFontSize(8);
    generatedPara.setAlignment(DocumentApp.HorizontalAlignment.RIGHT);
    generatedPara.setForegroundColor('#555555');
    
    // Red divider
    body.appendHorizontalRule();
    body.appendParagraph('').setSpacingAfter(6);

    // Executive summary box
    const summaryTable = body.appendTable([['', '']]);
    summaryTable.setBorderWidth(0);
    const summaryRow = summaryTable.getRow(0);
    const barCell = summaryRow.getCell(0);
    const summaryCell = summaryRow.getCell(1);
    barCell.setBackgroundColor('#cc0000');
    barCell.setWidth(6);
    summaryCell.setBackgroundColor('#f8fafc');
    summaryCell.setWidth(600);
    
    const summaryHeader = summaryCell.appendParagraph('EXECUTIVE SUMMARY');
    summaryHeader.setFontSize(9);
    summaryHeader.setBold(true);
    summaryHeader.setForegroundColor('#cc0000');
    summaryHeader.setSpacingAfter(6);
    
    const totalMeetings = meetings.length;
    const hotCount = meetings.filter(m => m.isHotTopic).length;
    const prepCount = meetings.filter(m => m.prepRequired).length;
    const conflictCount = meetings.filter(m => m.hasConflict).length;
    const summaryText = notes && notes.trim()
      ? notes.trim()
      : `Two-week outlook includes ${totalMeetings} meetings, ${hotCount} hot topics, ${prepCount} prep-required sessions, and ${conflictCount} conflicts.`;
    const summaryPara = summaryCell.appendParagraph(summaryText);
    summaryPara.setFontSize(9);
    summaryPara.setForegroundColor('#111111');
    summaryPara.setSpacingAfter(8);
    
    // Group meetings by date
    const meetingsByDate = {};
    meetings.forEach(m => {
      if (!meetingsByDate[m.date]) {
        meetingsByDate[m.date] = [];
      }
      meetingsByDate[m.date].push(m);
    });
    
    // Detect conflicts (meetings at same time on same day)
    for (const date of Object.keys(meetingsByDate)) {
      const dayMeetings = meetingsByDate[date];
      const timeSlots = {};
      
      dayMeetings.forEach(m => {
        const timeKey = m.time24 || '';
        if (!timeSlots[timeKey]) {
          timeSlots[timeKey] = [];
        }
        timeSlots[timeKey].push(m);
      });
      
      for (const timeKey of Object.keys(timeSlots)) {
        if (timeSlots[timeKey].length > 1) {
          timeSlots[timeKey].forEach(m => {
            m.hasConflict = true;
          });
        }
      }
    }
    
    const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

    // Key action items (deliverables due this week for Mike Sarcone)
    const actionHeader = body.appendParagraph("‚òë Sarcone's Upcoming Deliverables");
    actionHeader.setFontSize(10);
    actionHeader.setBold(true);
    actionHeader.setForegroundColor('#cc0000');
    actionHeader.setSpacingAfter(6);
    
    const exec1Deliverables = getExec1Deliverables();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const weekDay = today.getDay();
    const mondayOffset = weekDay === 0 ? -6 : 1 - weekDay;
    const weekStart = new Date(today);
    weekStart.setDate(today.getDate() + mondayOffset);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 4);
    
    const weekDeliverables = exec1Deliverables.filter(d => {
      if (!d.etaFull) return false;
      const due = new Date(d.etaFull + 'T00:00:00');
      return due >= weekStart && due <= weekEnd;
    });
    
    if (weekDeliverables.length === 0) {
      const none = body.appendParagraph('No deliverables due this week.');
      none.setFontSize(9);
      none.setForegroundColor('#666666');
      none.setSpacingAfter(10);
    } else {
      weekDeliverables.sort((a, b) => a.etaFull.localeCompare(b.etaFull));
      weekDeliverables.forEach(d => {
        const dueLabel = d.eta || d.etaFull;
        const ownerLabel = d.owner ? ` (${d.owner})` : '';
        const overdueLabel = d.isOverdue ? ' ‚Äî OVERDUE' : '';
        const itemText = `${dueLabel} ‚Äî ${d.description}${ownerLabel}${overdueLabel}`;
        const item = body.appendListItem(itemText);
        item.setFontSize(9);
        if (d.linkedMaterials) {
          try {
            item.editAsText().setLinkUrl(0, itemText.length - 1, d.linkedMaterials);
          } catch (e) {
            Logger.log('Link set failed for deliverable: ' + e);
          }
        }
      });
      body.appendParagraph('').setSpacingAfter(10);
    }
    
    function appendWeekTable(monday, label) {
      if (label) {
        const labelPara = body.appendParagraph(label);
        labelPara.setFontSize(9);
        labelPara.setBold(true);
        labelPara.setSpacingAfter(6);
      }
      
      const table = body.appendTable();
      table.setBorderWidth(0);
      
      const headerRow = table.appendTableRow();
      const contentRow = table.appendTableRow();
      
      for (let i = 0; i < 5; i++) {
        const dayDate = new Date(monday);
        dayDate.setDate(monday.getDate() + i);
        const dateShort = Utilities.formatDate(dayDate, Session.getScriptTimeZone(), 'MMM d');
        const dateStr = Utilities.formatDate(dayDate, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        const dayName = dayNames[i];
        
        const headerCell = headerRow.appendTableCell(`${dayName}\n${dateShort}`);
        headerCell.setBackgroundColor('#000000');
        headerCell.getChild(0).asParagraph().setForegroundColor('#ffffff');
        headerCell.getChild(0).asParagraph().setFontSize(8);
        headerCell.getChild(0).asParagraph().setBold(true);
        headerCell.setWidth(144);
        
        const bodyCell = contentRow.appendTableCell();
        bodyCell.setVerticalAlignment(DocumentApp.VerticalAlignment.TOP);
        
        const dayMeetings = meetingsByDate[dateStr] || [];
        dayMeetings.sort((a, b) => (a.time24 || '').localeCompare(b.time24 || ''));
        
        if (dayMeetings.length === 0) {
          const empty = bodyCell.appendParagraph('No meetings');
          empty.setFontSize(8);
          empty.setForegroundColor('#999999');
        } else {
          dayMeetings.forEach((m, idx) => {
            const timePara = bodyCell.appendParagraph(m.time || 'TBD');
            timePara.setBold(true);
            timePara.setFontSize(8);
            
            const titlePara = bodyCell.appendParagraph((includePrepMeetings && m.prepRequired ? '[PREP] ' : '') + m.title);
            titlePara.setFontSize(8);
            
            if (m.hotTopicLevel === 'urgent') {
              titlePara.setForegroundColor('#cc0000');
            } else if (m.hotTopicLevel === 'must-attend') {
              titlePara.setForegroundColor('#ea580c');
            } else if (m.isHotTopic) {
              titlePara.setForegroundColor('#444444');
            }
            
            if (m.hasConflict) {
              const conflictPara = bodyCell.appendParagraph('‚ö† CONFLICT');
              conflictPara.setForegroundColor('#ff6600');
              conflictPara.setFontSize(7);
              conflictPara.setBold(true);
            }
            
            if (idx < dayMeetings.length - 1) {
              bodyCell.appendParagraph('');
            }
          });
        }
      }
    }
    
    // Two-week calendar view
    const calendarHeader = body.appendParagraph('TWO-WEEK CALENDAR VIEW');
    calendarHeader.setFontSize(10);
    calendarHeader.setBold(true);
    calendarHeader.setForegroundColor('#cc0000');
    calendarHeader.setSpacingAfter(6);
    
    appendWeekTable(monday, 'Week 1');
    body.appendParagraph('');
    appendWeekTable(secondWeekMonday, 'Week 2');
    
    // Add Verizon footer
    body.appendParagraph('');
    const footer = body.appendParagraph('verizon');
    footer.setFontFamily('Arial');
    footer.setBold(true);
    footer.setFontSize(14);
    footer.setForegroundColor('#cc0000');
    
    // Save and get PDF
    doc.saveAndClose();
    
    // Convert to PDF
    const docFile = DriveApp.getFileById(doc.getId());
    const pdfBlob = docFile.getAs('application/pdf');
    pdfBlob.setName('Two_Week_Schedule_' + Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy-MM-dd') + '.pdf');
    
    // Save PDF to Drive
    const pdfFile = DriveApp.createFile(pdfBlob);
    
    // Delete the temporary Doc
    docFile.setTrashed(true);
    
    return {
      success: true,
      pdfUrl: pdfFile.getUrl(),
      pdfId: pdfFile.getId(),
      downloadUrl: 'https://drive.google.com/uc?export=download&id=' + pdfFile.getId()
    };
    
  } catch (error) {
    Logger.log('Error generating PDF: ' + error);
    return {
      success: false,
      error: error.toString()
    };
  }
}

/**
 * Get meetings data formatted for PDF export selection
 */
function getMeetingsForPDFExport() {
  try {
    const meetings = getMeetings();
    
    // Group by date and detect conflicts
    const meetingsByDate = {};
    meetings.forEach(m => {
      if (!meetingsByDate[m.date]) {
        meetingsByDate[m.date] = [];
      }
      meetingsByDate[m.date].push(m);
    });
    
    // Detect conflicts
    for (const date of Object.keys(meetingsByDate)) {
      const dayMeetings = meetingsByDate[date];
      const timeSlots = {};
      
      dayMeetings.forEach(m => {
        const timeKey = m.time24;
        if (!timeSlots[timeKey]) {
          timeSlots[timeKey] = [];
        }
        timeSlots[timeKey].push(m);
      });
      
      // Mark conflicts
      for (const timeKey of Object.keys(timeSlots)) {
        if (timeSlots[timeKey].length > 1) {
          timeSlots[timeKey].forEach(m => {
            m.hasConflict = true;
            m.conflictCount = timeSlots[timeKey].length;
          });
        }
      }
    }
    
    return {
      success: true,
      meetings: meetings,
      meetingsByDate: meetingsByDate
    };
    
  } catch (error) {
    Logger.log('Error getting meetings for PDF: ' + error);
    return {
      success: false,
      error: error.toString()
    };
  }
}
